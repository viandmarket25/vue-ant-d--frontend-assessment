var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  TSConfckParseError: () => TSConfckParseError,
  TSConfckParseNativeError: () => TSConfckParseNativeError,
  find: () => find,
  findNative: () => findNative,
  parse: () => parse,
  parseNative: () => parseNative,
  toJson: () => toJson
});

// src/find.ts
var import_path = __toModule(require("path"));
var import_fs = __toModule(require("fs"));
async function find(filename) {
  let dir = import_path.default.dirname(import_path.default.resolve(filename));
  while (dir) {
    const tsconfig = await tsconfigInDir(dir);
    if (tsconfig) {
      return tsconfig;
    } else {
      const parent = import_path.default.dirname(dir);
      if (parent === dir) {
        break;
      } else {
        dir = parent;
      }
    }
  }
  throw new Error(`no tsconfig file found for ${filename}`);
}
async function tsconfigInDir(dir) {
  const tsconfig = import_path.default.join(dir, "tsconfig.json");
  try {
    const stat = await import_fs.promises.stat(tsconfig);
    if (stat.isFile() || stat.isFIFO()) {
      return tsconfig;
    }
  } catch (e) {
    if (e.code !== "ENOENT") {
      throw e;
    }
  }
}

// src/to-json.ts
function toJson(tsconfigJson) {
  const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
  if (stripped.trim() === "") {
    return "{}";
  } else {
    return stripped;
  }
}
function stripDanglingComma(pseudoJson) {
  let insideString = false;
  let offset = 0;
  let result = "";
  let danglingCommaPos = null;
  for (let i = 0; i < pseudoJson.length; i++) {
    const currentCharacter = pseudoJson[i];
    if (currentCharacter === '"') {
      const escaped = isEscaped(pseudoJson, i);
      if (!escaped) {
        insideString = !insideString;
      }
    }
    if (insideString) {
      danglingCommaPos = null;
      continue;
    }
    if (currentCharacter === ",") {
      danglingCommaPos = i;
      continue;
    }
    if (danglingCommaPos) {
      if (currentCharacter === "}" || currentCharacter === "]") {
        result += pseudoJson.slice(offset, danglingCommaPos) + " ";
        offset = danglingCommaPos + 1;
        danglingCommaPos = null;
      } else if (!currentCharacter.match(/\s/)) {
        danglingCommaPos = null;
      }
    }
  }
  return result + pseudoJson.substring(offset);
}
function isEscaped(jsonString, quotePosition) {
  let index = quotePosition - 1;
  let backslashCount = 0;
  while (jsonString[index] === "\\") {
    index -= 1;
    backslashCount += 1;
  }
  return Boolean(backslashCount % 2);
}
function strip(string, start, end) {
  return string.slice(start, end).replace(/\S/g, " ");
}
var singleComment = Symbol("singleComment");
var multiComment = Symbol("multiComment");
function stripJsonComments(jsonString) {
  let isInsideString = false;
  let isInsideComment = false;
  let offset = 0;
  let result = "";
  for (let index = 0; index < jsonString.length; index++) {
    const currentCharacter = jsonString[index];
    const nextCharacter = jsonString[index + 1];
    if (!isInsideComment && currentCharacter === '"') {
      const escaped = isEscaped(jsonString, index);
      if (!escaped) {
        isInsideString = !isInsideString;
      }
    }
    if (isInsideString) {
      continue;
    }
    if (!isInsideComment && currentCharacter + nextCharacter === "//") {
      result += jsonString.slice(offset, index);
      offset = index;
      isInsideComment = singleComment;
      index++;
    } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
      index++;
      isInsideComment = false;
      result += strip(jsonString, offset, index);
      offset = index;
    } else if (isInsideComment === singleComment && currentCharacter === "\n") {
      isInsideComment = false;
      result += strip(jsonString, offset, index);
      offset = index;
    } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
      result += jsonString.slice(offset, index);
      offset = index;
      isInsideComment = multiComment;
      index++;
    } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
      index++;
      isInsideComment = false;
      result += strip(jsonString, offset, index + 1);
      offset = index + 1;
    }
  }
  return result + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
}
function stripBom(string) {
  if (string.charCodeAt(0) === 65279) {
    return string.slice(1);
  }
  return string;
}

// src/parse.ts
var import_path3 = __toModule(require("path"));
var import_fs3 = __toModule(require("fs"));
var import_module = __toModule(require("module"));

// src/util.ts
var import_path2 = __toModule(require("path"));
var import_fs2 = __toModule(require("fs"));
var POSIX_SEP_RE = new RegExp("\\" + import_path2.default.posix.sep, "g");
var NATIVE_SEP_RE = new RegExp("\\" + import_path2.default.sep, "g");
var PATTERN_REGEX_CACHE = new Map();
var GLOB_ALL_PATTERN = `**/*`;
var DEFAULT_EXTENSIONS = [".ts", ".tsx", ".mts", ".cts"];
var DEFAULT_EXTENSIONS_RE_GROUP = `\\.(?:${DEFAULT_EXTENSIONS.map((ext) => ext.substring(1)).join("|")})`;
var dynamicImportDefault = new Function("path", "return import(path).then(m => m.default)");
async function loadTS() {
  try {
    return dynamicImportDefault("typescript");
  } catch (e) {
    console.error('typescript must be installed to use "native" functions');
    throw e;
  }
}
async function resolveTSConfig(filename) {
  const basename = import_path2.default.basename(filename);
  if (basename !== "tsconfig.json") {
    return;
  }
  const tsconfig = import_path2.default.resolve(filename);
  try {
    const stat = await import_fs2.promises.stat(tsconfig);
    if (stat.isFile() || stat.isFIFO()) {
      return tsconfig;
    }
  } catch (e) {
    if (e.code !== "ENOENT") {
      throw e;
    }
  }
  throw new Error(`no tsconfig file found for ${filename}`);
}
function posix2native(filename) {
  return import_path2.default.posix.sep !== import_path2.default.sep && filename.includes(import_path2.default.posix.sep) ? filename.replace(POSIX_SEP_RE, import_path2.default.sep) : filename;
}
function native2posix(filename) {
  return import_path2.default.posix.sep !== import_path2.default.sep && filename.includes(import_path2.default.sep) ? filename.replace(NATIVE_SEP_RE, import_path2.default.posix.sep) : filename;
}
function resolve2posix(dir, filename) {
  if (import_path2.default.sep === import_path2.default.posix.sep) {
    return dir ? import_path2.default.resolve(dir, filename) : import_path2.default.resolve(filename);
  }
  return native2posix(dir ? import_path2.default.resolve(posix2native(dir), posix2native(filename)) : import_path2.default.resolve(posix2native(filename)));
}
function resolveReferencedTSConfigFiles(result) {
  const dir = import_path2.default.dirname(result.tsconfigFile);
  return result.tsconfig.references.map((ref) => {
    const refPath = ref.path.endsWith(".json") ? ref.path : import_path2.default.join(ref.path, "tsconfig.json");
    return resolve2posix(dir, refPath);
  });
}
function resolveSolutionTSConfig(filename, result) {
  if (result.referenced && DEFAULT_EXTENSIONS.some((ext) => filename.endsWith(ext)) && !isIncluded(filename, result)) {
    const solutionTSConfig = result.referenced.find((referenced) => isIncluded(filename, referenced));
    if (solutionTSConfig) {
      return __spreadProps(__spreadValues({}, solutionTSConfig), {
        solution: result
      });
    }
  }
  return result;
}
function isIncluded(filename, result) {
  const dir = native2posix(import_path2.default.dirname(result.tsconfigFile));
  const files = (result.tsconfig.files || []).map((file) => resolve2posix(dir, file));
  const absoluteFilename = resolve2posix(null, filename);
  if (files.includes(filename)) {
    return true;
  }
  const isIncluded2 = isGlobMatch(absoluteFilename, dir, result.tsconfig.include || (result.tsconfig.files ? [] : [GLOB_ALL_PATTERN]));
  if (isIncluded2) {
    const isExcluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || []);
    return !isExcluded;
  }
  return false;
}
function isGlobMatch(filename, dir, patterns) {
  return patterns.some((pattern) => {
    let lastWildcardIndex = pattern.length;
    let hasWildcard = false;
    for (let i = pattern.length - 1; i > -1; i--) {
      if (pattern[i] === "*" || pattern[i] === "?") {
        lastWildcardIndex = i;
        hasWildcard = true;
        break;
      }
    }
    if (lastWildcardIndex < pattern.length - 1 && !filename.endsWith(pattern.slice(lastWildcardIndex + 1))) {
      return false;
    }
    if (pattern.endsWith("*") && !DEFAULT_EXTENSIONS.some((ext) => filename.endsWith(ext))) {
      return false;
    }
    if (pattern === GLOB_ALL_PATTERN) {
      return filename.startsWith(`${dir}/`);
    }
    const resolvedPattern = resolve2posix(dir, pattern);
    let firstWildcardIndex = -1;
    for (let i = 0; i < resolvedPattern.length; i++) {
      if (resolvedPattern[i] === "*" || resolvedPattern[i] === "?") {
        firstWildcardIndex = i;
        hasWildcard = true;
        break;
      }
    }
    if (firstWildcardIndex > 1 && !filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))) {
      return false;
    }
    if (!hasWildcard) {
      return filename === resolvedPattern;
    }
    if (PATTERN_REGEX_CACHE.has(resolvedPattern)) {
      return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename);
    }
    const regex = pattern2regex(resolvedPattern);
    PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
    return regex.test(filename);
  });
}
function pattern2regex(resolvedPattern) {
  let regexStr = "^";
  for (let i = 0; i < resolvedPattern.length; i++) {
    const char = resolvedPattern[i];
    if (char === "?") {
      regexStr += "[^\\/]";
      continue;
    }
    if (char === "*") {
      if (resolvedPattern[i + 1] === "*" && resolvedPattern[i + 2] === "/") {
        i += 2;
        regexStr += "(?:[^\\/]*\\/)*";
        continue;
      }
      regexStr += "[^\\/]*";
      continue;
    }
    if ("/.+^${}()|[]\\".includes(char)) {
      regexStr += `\\`;
    }
    regexStr += char;
  }
  if (resolvedPattern.endsWith("*")) {
    regexStr += DEFAULT_EXTENSIONS_RE_GROUP;
  }
  regexStr += "$";
  return new RegExp(regexStr);
}

// src/parse.ts
async function parse(filename, options) {
  const cache = options == null ? void 0 : options.cache;
  if (cache == null ? void 0 : cache.has(filename)) {
    return cache.get(filename);
  }
  let tsconfigFile;
  if (options == null ? void 0 : options.resolveWithEmptyIfConfigNotFound) {
    try {
      tsconfigFile = await resolveTSConfig(filename) || await find(filename);
    } catch (e) {
      const notFoundResult = {
        tsconfigFile: "no_tsconfig_file_found",
        tsconfig: {}
      };
      cache == null ? void 0 : cache.set(filename, notFoundResult);
      return notFoundResult;
    }
  } else {
    tsconfigFile = await resolveTSConfig(filename) || await find(filename);
  }
  let result;
  if (cache == null ? void 0 : cache.has(tsconfigFile)) {
    result = cache.get(tsconfigFile);
  } else {
    result = await parseFile(tsconfigFile, cache);
    await Promise.all([parseExtends(result, cache), parseReferences(result, cache)]);
    cache == null ? void 0 : cache.set(tsconfigFile, result);
  }
  result = resolveSolutionTSConfig(filename, result);
  cache == null ? void 0 : cache.set(filename, result);
  return result;
}
async function parseFile(tsconfigFile, cache) {
  if (cache == null ? void 0 : cache.has(tsconfigFile)) {
    return cache.get(tsconfigFile);
  }
  try {
    const tsconfigJson = await import_fs3.promises.readFile(tsconfigFile, "utf-8");
    const json = toJson(tsconfigJson);
    const result = {
      tsconfigFile,
      tsconfig: normalizeTSConfig(JSON.parse(json), import_path3.default.dirname(tsconfigFile))
    };
    cache == null ? void 0 : cache.set(tsconfigFile, result);
    return result;
  } catch (e) {
    throw new TSConfckParseError(`parsing ${tsconfigFile} failed: ${e}`, "PARSE_FILE", tsconfigFile, e);
  }
}
function normalizeTSConfig(tsconfig, dir) {
  var _a;
  if (((_a = tsconfig.compilerOptions) == null ? void 0 : _a.baseUrl) && !import_path3.default.isAbsolute(tsconfig.compilerOptions.baseUrl)) {
    tsconfig.compilerOptions.baseUrl = resolve2posix(dir, tsconfig.compilerOptions.baseUrl);
  }
  return tsconfig;
}
async function parseReferences(result, cache) {
  if (!result.tsconfig.references) {
    return;
  }
  const referencedFiles = resolveReferencedTSConfigFiles(result);
  const referenced = await Promise.all(referencedFiles.map((file) => parseFile(file, cache)));
  await Promise.all(referenced.map((ref) => parseExtends(ref, cache)));
  result.referenced = referenced;
}
async function parseExtends(result, cache) {
  if (!result.tsconfig.extends) {
    return;
  }
  const extended = [
    { tsconfigFile: result.tsconfigFile, tsconfig: JSON.parse(JSON.stringify(result.tsconfig)) }
  ];
  while (extended[extended.length - 1].tsconfig.extends) {
    const extending = extended[extended.length - 1];
    const extendedTSConfigFile = resolveExtends(extending.tsconfig.extends, extending.tsconfigFile);
    if (extended.some((x) => x.tsconfigFile === extendedTSConfigFile)) {
      const circle = extended.concat({ tsconfigFile: extendedTSConfigFile, tsconfig: null }).map((e) => e.tsconfigFile).join(" -> ");
      throw new TSConfckParseError(`Circular dependency in "extends": ${circle}`, "EXTENDS_CIRCULAR", result.tsconfigFile);
    }
    extended.push(await parseFile(extendedTSConfigFile, cache));
  }
  result.extended = extended;
  for (const ext of result.extended.slice(1)) {
    extendTSConfig(result, ext);
  }
}
function resolveExtends(extended, from) {
  try {
    return (0, import_module.createRequire)(from).resolve(extended);
  } catch (e) {
    throw new TSConfckParseError(`failed to resolve "extends":"${extended}" in ${from}`, "EXTENDS_RESOLVE", from, e);
  }
}
var EXTENDABLE_KEYS = [
  "compilerOptions",
  "files",
  "include",
  "exclude",
  "watchOptions",
  "compileOnSave",
  "typeAcquisition",
  "buildOptions"
];
function extendTSConfig(extending, extended) {
  const extendingConfig = extending.tsconfig;
  const extendedConfig = extended.tsconfig;
  const relativePath = native2posix(import_path3.default.relative(import_path3.default.dirname(extending.tsconfigFile), import_path3.default.dirname(extended.tsconfigFile)));
  for (const key of Object.keys(extendedConfig).filter((key2) => EXTENDABLE_KEYS.includes(key2))) {
    if (key === "compilerOptions") {
      if (!extendingConfig.compilerOptions) {
        extendingConfig.compilerOptions = {};
      }
      for (const option of Object.keys(extendedConfig.compilerOptions)) {
        if (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) {
          continue;
        }
        extendingConfig.compilerOptions[option] = rebaseRelative(option, extendedConfig.compilerOptions[option], relativePath);
      }
    } else if (extendingConfig[key] === void 0) {
      if (key === "watchOptions") {
        extendingConfig.watchOptions = {};
        for (const option of Object.keys(extendedConfig.watchOptions)) {
          extendingConfig.watchOptions[option] = rebaseRelative(option, extendedConfig.watchOptions[option], relativePath);
        }
      } else {
        extendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);
      }
    }
  }
}
var REBASE_KEYS = [
  "files",
  "include",
  "exclude",
  "baseUrl",
  "rootDir",
  "rootDirs",
  "typeRoots",
  "outDir",
  "outFile",
  "declarationDir",
  "excludeDirectories",
  "excludeFiles"
];
function rebaseRelative(key, value, prependPath) {
  if (!REBASE_KEYS.includes(key)) {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((x) => rebasePath(x, prependPath));
  } else {
    return rebasePath(value, prependPath);
  }
}
function rebasePath(value, prependPath) {
  if (import_path3.default.isAbsolute(value)) {
    return value;
  } else {
    return import_path3.default.posix.normalize(import_path3.default.posix.join(prependPath, value));
  }
}
var TSConfckParseError = class extends Error {
  constructor(message, code, tsconfigFile, cause) {
    super(message);
    Object.setPrototypeOf(this, TSConfckParseError.prototype);
    this.name = TSConfckParseError.name;
    this.code = code;
    this.cause = cause;
    this.tsconfigFile = tsconfigFile;
  }
};

// src/find-native.ts
var import_path4 = __toModule(require("path"));
async function findNative(filename) {
  const ts = await loadTS();
  const { findConfigFile, sys } = ts;
  const tsconfigFile = findConfigFile(import_path4.default.dirname(import_path4.default.resolve(filename)), sys.fileExists);
  if (!tsconfigFile) {
    throw new Error(`no tsconfig file found for ${filename}`);
  }
  return tsconfigFile;
}

// src/parse-native.ts
var import_path5 = __toModule(require("path"));
async function parseNative(filename, options) {
  const cache = options == null ? void 0 : options.cache;
  if (cache == null ? void 0 : cache.has(filename)) {
    return cache.get(filename);
  }
  let tsconfigFile;
  if (options == null ? void 0 : options.resolveWithEmptyIfConfigNotFound) {
    try {
      tsconfigFile = await resolveTSConfig(filename);
      if (!tsconfigFile) {
        tsconfigFile = await findNative(filename);
      }
    } catch (e) {
      const notFoundResult = {
        tsconfigFile: "no_tsconfig_file_found",
        tsconfig: {},
        result: null
      };
      cache == null ? void 0 : cache.set(filename, notFoundResult);
      return notFoundResult;
    }
  } else {
    tsconfigFile = await resolveTSConfig(filename);
    if (!tsconfigFile) {
      tsconfigFile = await findNative(filename);
    }
  }
  let result;
  if (cache == null ? void 0 : cache.has(tsconfigFile)) {
    result = cache.get(tsconfigFile);
  } else {
    const ts = await loadTS();
    result = await parseFile2(tsconfigFile, ts, options);
    await parseReferences2(result, ts, options);
    cache == null ? void 0 : cache.set(tsconfigFile, result);
  }
  result = resolveSolutionTSConfig(filename, result);
  cache == null ? void 0 : cache.set(filename, result);
  return result;
}
async function parseFile2(tsconfigFile, ts, options) {
  const cache = options == null ? void 0 : options.cache;
  if (cache == null ? void 0 : cache.has(tsconfigFile)) {
    return cache.get(tsconfigFile);
  }
  const posixTSConfigFile = native2posix(tsconfigFile);
  const { parseJsonConfigFileContent, readConfigFile, sys } = ts;
  const { config, error } = readConfigFile(posixTSConfigFile, sys.readFile);
  if (error) {
    throw new TSConfckParseNativeError(error, tsconfigFile, null);
  }
  const host = {
    useCaseSensitiveFileNames: false,
    readDirectory: sys.readDirectory,
    fileExists: sys.fileExists,
    readFile: sys.readFile
  };
  if (options == null ? void 0 : options.ignoreSourceFiles) {
    config.files = [];
    config.include = [];
  }
  const nativeResult = parseJsonConfigFileContent(config, host, import_path5.default.dirname(posixTSConfigFile), void 0, posixTSConfigFile);
  checkErrors(nativeResult, tsconfigFile);
  const result = {
    tsconfigFile,
    tsconfig: result2tsconfig(nativeResult, ts),
    result: nativeResult
  };
  cache == null ? void 0 : cache.set(tsconfigFile, result);
  return result;
}
async function parseReferences2(result, ts, options) {
  if (!result.tsconfig.references) {
    return;
  }
  const referencedFiles = resolveReferencedTSConfigFiles(result);
  result.referenced = await Promise.all(referencedFiles.map((file) => parseFile2(file, ts, options)));
}
function checkErrors(nativeResult, tsconfigFile) {
  var _a;
  const ignoredErrorCodes = [
    18002,
    18003
  ];
  const criticalError = (_a = nativeResult.errors) == null ? void 0 : _a.find((error) => error.category === 1 && !ignoredErrorCodes.includes(error.code));
  if (criticalError) {
    throw new TSConfckParseNativeError(criticalError, tsconfigFile, nativeResult);
  }
}
function result2tsconfig(result, ts) {
  const tsconfig = JSON.parse(JSON.stringify(result.raw));
  const ignoredOptions = ["configFilePath", "pathsBasePath"];
  if (result.options && Object.keys(result.options).some((o) => !ignoredOptions.includes(o))) {
    tsconfig.compilerOptions = __spreadValues({}, result.options);
    for (const ignored of ignoredOptions) {
      delete tsconfig.compilerOptions[ignored];
    }
  }
  const compilerOptions = tsconfig.compilerOptions;
  if (compilerOptions) {
    if (compilerOptions.lib != null) {
      compilerOptions.lib = compilerOptions.lib.map((x) => x.replace(/^lib\./, "").replace(/\.d\.ts$/, ""));
    }
    const enumProperties = [
      { name: "importsNotUsedAsValues", enumeration: ts.ImportsNotUsedAsValues },
      { name: "module", enumeration: ts.ModuleKind },
      {
        name: "moduleResolution",
        enumeration: { 1: "classic", 2: "node" }
      },
      {
        name: "newLine",
        enumeration: { 0: "crlf", 1: "lf" }
      },
      { name: "target", enumeration: ts.ScriptTarget }
    ];
    for (const prop of enumProperties) {
      if (compilerOptions[prop.name] != null && typeof compilerOptions[prop.name] === "number") {
        compilerOptions[prop.name] = prop.enumeration[compilerOptions[prop.name]].toLowerCase();
      }
    }
  }
  if (result.watchOptions) {
    tsconfig.watchOptions = __spreadValues({}, result.watchOptions);
  }
  const watchOptions = tsconfig.watchOptions;
  if (watchOptions) {
    const enumProperties = [
      { name: "watchFile", enumeration: ts.WatchFileKind },
      { name: "watchDirectory", enumeration: ts.WatchDirectoryKind },
      { name: "fallbackPolling", enumeration: ts.PollingWatchKind }
    ];
    for (const prop of enumProperties) {
      if (watchOptions[prop.name] != null && typeof watchOptions[prop.name] === "number") {
        const enumVal = prop.enumeration[watchOptions[prop.name]];
        watchOptions[prop.name] = enumVal.charAt(0).toLowerCase() + enumVal.slice(1);
      }
    }
  }
  if (tsconfig.compileOnSave === false) {
    delete tsconfig.compileOnSave;
  }
  return tsconfig;
}
var TSConfckParseNativeError = class extends Error {
  constructor(diagnostic, tsconfigFile, result) {
    super(diagnostic.messageText);
    Object.setPrototypeOf(this, TSConfckParseNativeError.prototype);
    this.name = TSConfckParseNativeError.name;
    this.code = `TS ${diagnostic.code}`;
    this.diagnostic = diagnostic;
    this.result = result;
    this.tsconfigFile = tsconfigFile;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TSConfckParseError,
  TSConfckParseNativeError,
  find,
  findNative,
  parse,
  parseNative,
  toJson
});
//# sourceMappingURL=index.cjs.map
