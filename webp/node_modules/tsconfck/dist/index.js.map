{
  "version": 3,
  "sources": ["../src/find.ts", "../src/to-json.ts", "../src/parse.ts", "../src/util.ts", "../src/find-native.ts", "../src/parse-native.ts"],
  "sourcesContent": ["import path from 'path';\nimport { promises as fs } from 'fs';\n\n/**\n * find the closest tsconfig.json file\n *\n * @param {string} filename - path to file to find tsconfig for (absolute or relative to cwd)\n * @returns {Promise<string>} absolute path to closest tsconfig.json\n */\nexport async function find(filename: string) {\n\tlet dir = path.dirname(path.resolve(filename));\n\twhile (dir) {\n\t\tconst tsconfig = await tsconfigInDir(dir);\n\t\tif (tsconfig) {\n\t\t\treturn tsconfig;\n\t\t} else {\n\t\t\tconst parent = path.dirname(dir);\n\t\t\tif (parent === dir) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdir = parent;\n\t\t\t}\n\t\t}\n\t}\n\tthrow new Error(`no tsconfig file found for ${filename}`);\n}\n\nasync function tsconfigInDir(dir: string): Promise<string | void> {\n\tconst tsconfig = path.join(dir, 'tsconfig.json');\n\ttry {\n\t\tconst stat = await fs.stat(tsconfig);\n\t\tif (stat.isFile() || stat.isFIFO()) {\n\t\t\treturn tsconfig;\n\t\t}\n\t} catch (e) {\n\t\t// ignore does not exist error\n\t\tif (e.code !== 'ENOENT') {\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n", "/*\n this file contains code from strip-bom and strip-json-comments by Sindre Sorhus\n https://github.com/sindresorhus/strip-json-comments/blob/v4.0.0/index.js\n https://github.com/sindresorhus/strip-bom/blob/v5.0.0/index.js\n licensed under MIT, see ../LICENSE\n*/\n\n/**\n * convert content of tsconfig.json to regular json\n *\n * @param {string} tsconfigJson - content of tsconfig.json\n * @returns {string} content as regular json, comments and dangling commas have been replaced with whitespace\n */\nexport function toJson(tsconfigJson: string): string {\n\tconst stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));\n\tif (stripped.trim() === '') {\n\t\t// only whitespace left after stripping, return empty object so that JSON.parse still works\n\t\treturn '{}';\n\t} else {\n\t\treturn stripped;\n\t}\n}\n\n/**\n * replace dangling commas from pseudo-json string with single space\n * implementation heavily inspired by strip-json-comments\n */\nfunction stripDanglingComma(pseudoJson: string) {\n\tlet insideString = false;\n\tlet offset = 0;\n\tlet result = '';\n\tlet danglingCommaPos = null;\n\tfor (let i = 0; i < pseudoJson.length; i++) {\n\t\tconst currentCharacter = pseudoJson[i];\n\t\tif (currentCharacter === '\"') {\n\t\t\tconst escaped = isEscaped(pseudoJson, i);\n\t\t\tif (!escaped) {\n\t\t\t\tinsideString = !insideString;\n\t\t\t}\n\t\t}\n\t\tif (insideString) {\n\t\t\tdanglingCommaPos = null;\n\t\t\tcontinue;\n\t\t}\n\t\tif (currentCharacter === ',') {\n\t\t\tdanglingCommaPos = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (danglingCommaPos) {\n\t\t\tif (currentCharacter === '}' || currentCharacter === ']') {\n\t\t\t\tresult += pseudoJson.slice(offset, danglingCommaPos) + ' ';\n\t\t\t\toffset = danglingCommaPos + 1;\n\t\t\t\tdanglingCommaPos = null;\n\t\t\t} else if (!currentCharacter.match(/\\s/)) {\n\t\t\t\tdanglingCommaPos = null;\n\t\t\t}\n\t\t}\n\t}\n\treturn result + pseudoJson.substring(offset);\n}\n\n// start strip-json-comments\nfunction isEscaped(jsonString: string, quotePosition: number) {\n\tlet index = quotePosition - 1;\n\tlet backslashCount = 0;\n\n\twhile (jsonString[index] === '\\\\') {\n\t\tindex -= 1;\n\t\tbackslashCount += 1;\n\t}\n\n\treturn Boolean(backslashCount % 2);\n}\n\nfunction strip(string: string, start?: number, end?: number) {\n\treturn string.slice(start, end).replace(/\\S/g, ' ');\n}\n\nconst singleComment = Symbol('singleComment');\nconst multiComment = Symbol('multiComment');\n\nfunction stripJsonComments(jsonString: string) {\n\tlet isInsideString = false;\n\tlet isInsideComment: false | symbol = false;\n\tlet offset = 0;\n\tlet result = '';\n\n\tfor (let index = 0; index < jsonString.length; index++) {\n\t\tconst currentCharacter = jsonString[index];\n\t\tconst nextCharacter = jsonString[index + 1];\n\n\t\tif (!isInsideComment && currentCharacter === '\"') {\n\t\t\tconst escaped = isEscaped(jsonString, index);\n\t\t\tif (!escaped) {\n\t\t\t\tisInsideString = !isInsideString;\n\t\t\t}\n\t\t}\n\n\t\tif (isInsideString) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isInsideComment && currentCharacter + nextCharacter === '//') {\n\t\t\tresult += jsonString.slice(offset, index);\n\t\t\toffset = index;\n\t\t\tisInsideComment = singleComment;\n\t\t\tindex++;\n\t\t} else if (isInsideComment === singleComment && currentCharacter + nextCharacter === '\\r\\n') {\n\t\t\tindex++;\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index);\n\t\t\toffset = index;\n\t\t} else if (isInsideComment === singleComment && currentCharacter === '\\n') {\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index);\n\t\t\toffset = index;\n\t\t} else if (!isInsideComment && currentCharacter + nextCharacter === '/*') {\n\t\t\tresult += jsonString.slice(offset, index);\n\t\t\toffset = index;\n\t\t\tisInsideComment = multiComment;\n\t\t\tindex++;\n\t\t} else if (isInsideComment === multiComment && currentCharacter + nextCharacter === '*/') {\n\t\t\tindex++;\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index + 1);\n\t\t\toffset = index + 1;\n\t\t}\n\t}\n\n\treturn result + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));\n}\n// end strip-json-comments\n\n// start strip-bom\nfunction stripBom(string: string) {\n\t// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n\t// conversion translates it to FEFF (UTF-16 BOM).\n\tif (string.charCodeAt(0) === 0xfeff) {\n\t\treturn string.slice(1);\n\t}\n\treturn string;\n}\n// end strip-bom\n", "import path from 'path';\nimport { promises as fs } from 'fs';\nimport { createRequire } from 'module';\nimport { find } from './find.js';\nimport { toJson } from './to-json.js';\nimport {\n\tnative2posix,\n\tresolve2posix,\n\tresolveReferencedTSConfigFiles,\n\tresolveSolutionTSConfig,\n\tresolveTSConfig\n} from './util';\n\n/**\n * parse the closest tsconfig.json file\n *\n * @param {string} filename - path to a tsconfig.json or a .ts source file (absolute or relative to cwd)\n * @param {TSConfckParseOptions} options - options\n * @returns {Promise<TSConfckParseResult>}\n * @throws {TSConfckParseError}\n */\nexport async function parse(\n\tfilename: string,\n\toptions?: TSConfckParseOptions\n): Promise<TSConfckParseResult> {\n\tconst cache = options?.cache;\n\tif (cache?.has(filename)) {\n\t\treturn cache.get(filename)!;\n\t}\n\tlet tsconfigFile;\n\tif (options?.resolveWithEmptyIfConfigNotFound) {\n\t\ttry {\n\t\t\ttsconfigFile = (await resolveTSConfig(filename)) || (await find(filename));\n\t\t} catch (e) {\n\t\t\tconst notFoundResult = {\n\t\t\t\ttsconfigFile: 'no_tsconfig_file_found',\n\t\t\t\ttsconfig: {}\n\t\t\t};\n\t\t\tcache?.set(filename, notFoundResult);\n\t\t\treturn notFoundResult;\n\t\t}\n\t} else {\n\t\ttsconfigFile = (await resolveTSConfig(filename)) || (await find(filename));\n\t}\n\tlet result;\n\tif (cache?.has(tsconfigFile)) {\n\t\tresult = cache.get(tsconfigFile)!;\n\t} else {\n\t\tresult = await parseFile(tsconfigFile, cache);\n\t\tawait Promise.all([parseExtends(result, cache), parseReferences(result, cache)]);\n\t\tcache?.set(tsconfigFile, result);\n\t}\n\tresult = resolveSolutionTSConfig(filename, result);\n\tcache?.set(filename, result);\n\treturn result;\n}\n\nasync function parseFile(\n\ttsconfigFile: string,\n\tcache?: Map<string, TSConfckParseResult>\n): Promise<TSConfckParseResult> {\n\tif (cache?.has(tsconfigFile)) {\n\t\treturn cache.get(tsconfigFile)!;\n\t}\n\ttry {\n\t\tconst tsconfigJson = await fs.readFile(tsconfigFile, 'utf-8');\n\t\tconst json = toJson(tsconfigJson);\n\t\tconst result = {\n\t\t\ttsconfigFile,\n\t\t\ttsconfig: normalizeTSConfig(JSON.parse(json), path.dirname(tsconfigFile))\n\t\t};\n\t\tcache?.set(tsconfigFile, result);\n\t\treturn result;\n\t} catch (e) {\n\t\tthrow new TSConfckParseError(\n\t\t\t`parsing ${tsconfigFile} failed: ${e}`,\n\t\t\t'PARSE_FILE',\n\t\t\ttsconfigFile,\n\t\t\te\n\t\t);\n\t}\n}\n\n/**\n * normalize to match the output of ts.parseJsonConfigFileContent\n *\n * @param tsconfig\n */\nfunction normalizeTSConfig(tsconfig: any, dir: string) {\n\t// set baseUrl to absolute path\n\tif (tsconfig.compilerOptions?.baseUrl && !path.isAbsolute(tsconfig.compilerOptions.baseUrl)) {\n\t\ttsconfig.compilerOptions.baseUrl = resolve2posix(dir, tsconfig.compilerOptions.baseUrl);\n\t}\n\treturn tsconfig;\n}\n\nasync function parseReferences(\n\tresult: TSConfckParseResult,\n\tcache?: Map<string, TSConfckParseResult>\n) {\n\tif (!result.tsconfig.references) {\n\t\treturn;\n\t}\n\tconst referencedFiles = resolveReferencedTSConfigFiles(result);\n\tconst referenced = await Promise.all(referencedFiles.map((file) => parseFile(file, cache)));\n\tawait Promise.all(referenced.map((ref) => parseExtends(ref, cache)));\n\tresult.referenced = referenced;\n}\n\nasync function parseExtends(result: TSConfckParseResult, cache?: Map<string, TSConfckParseResult>) {\n\tif (!result.tsconfig.extends) {\n\t\treturn;\n\t}\n\t// use result as first element in extended\n\t// but dereference tsconfig so that mergeExtended can modify the original without affecting extended[0]\n\tconst extended = [\n\t\t{ tsconfigFile: result.tsconfigFile, tsconfig: JSON.parse(JSON.stringify(result.tsconfig)) }\n\t];\n\n\twhile (extended[extended.length - 1].tsconfig.extends) {\n\t\tconst extending = extended[extended.length - 1];\n\t\tconst extendedTSConfigFile = resolveExtends(extending.tsconfig.extends, extending.tsconfigFile);\n\t\tif (extended.some((x) => x.tsconfigFile === extendedTSConfigFile)) {\n\t\t\tconst circle = extended\n\t\t\t\t.concat({ tsconfigFile: extendedTSConfigFile, tsconfig: null })\n\t\t\t\t.map((e) => e.tsconfigFile)\n\t\t\t\t.join(' -> ');\n\t\t\tthrow new TSConfckParseError(\n\t\t\t\t`Circular dependency in \"extends\": ${circle}`,\n\t\t\t\t'EXTENDS_CIRCULAR',\n\t\t\t\tresult.tsconfigFile\n\t\t\t);\n\t\t}\n\t\textended.push(await parseFile(extendedTSConfigFile, cache));\n\t}\n\tresult.extended = extended;\n\t// skip first as it is the original config\n\tfor (const ext of result.extended!.slice(1)) {\n\t\textendTSConfig(result, ext);\n\t}\n}\n\nfunction resolveExtends(extended: string, from: string): string {\n\ttry {\n\t\treturn createRequire(from).resolve(extended);\n\t} catch (e) {\n\t\tthrow new TSConfckParseError(\n\t\t\t`failed to resolve \"extends\":\"${extended}\" in ${from}`,\n\t\t\t'EXTENDS_RESOLVE',\n\t\t\tfrom,\n\t\t\te\n\t\t);\n\t}\n}\n\n// references, extends and custom keys are not carried over\nconst EXTENDABLE_KEYS = [\n\t'compilerOptions',\n\t'files',\n\t'include',\n\t'exclude',\n\t'watchOptions',\n\t'compileOnSave',\n\t'typeAcquisition',\n\t'buildOptions'\n];\nfunction extendTSConfig(extending: TSConfckParseResult, extended: TSConfckParseResult): any {\n\tconst extendingConfig = extending.tsconfig;\n\tconst extendedConfig = extended.tsconfig;\n\tconst relativePath = native2posix(\n\t\tpath.relative(path.dirname(extending.tsconfigFile), path.dirname(extended.tsconfigFile))\n\t);\n\tfor (const key of Object.keys(extendedConfig).filter((key) => EXTENDABLE_KEYS.includes(key))) {\n\t\tif (key === 'compilerOptions') {\n\t\t\tif (!extendingConfig.compilerOptions) {\n\t\t\t\textendingConfig.compilerOptions = {};\n\t\t\t}\n\t\t\tfor (const option of Object.keys(extendedConfig.compilerOptions)) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) {\n\t\t\t\t\tcontinue; // already set\n\t\t\t\t}\n\t\t\t\textendingConfig.compilerOptions[option] = rebaseRelative(\n\t\t\t\t\toption,\n\t\t\t\t\textendedConfig.compilerOptions[option],\n\t\t\t\t\trelativePath\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (extendingConfig[key] === undefined) {\n\t\t\tif (key === 'watchOptions') {\n\t\t\t\textendingConfig.watchOptions = {};\n\t\t\t\tfor (const option of Object.keys(extendedConfig.watchOptions)) {\n\t\t\t\t\textendingConfig.watchOptions[option] = rebaseRelative(\n\t\t\t\t\t\toption,\n\t\t\t\t\t\textendedConfig.watchOptions[option],\n\t\t\t\t\t\trelativePath\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\textendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst REBASE_KEYS = [\n\t// root\n\t'files',\n\t'include',\n\t'exclude',\n\t// compilerOptions\n\t'baseUrl',\n\t'rootDir',\n\t'rootDirs',\n\t'typeRoots',\n\t'outDir',\n\t'outFile',\n\t'declarationDir',\n\t// watchOptions\n\t'excludeDirectories',\n\t'excludeFiles'\n];\n\ntype PathValue = string | string[];\n\nfunction rebaseRelative(key: string, value: PathValue, prependPath: string): PathValue {\n\tif (!REBASE_KEYS.includes(key)) {\n\t\treturn value;\n\t}\n\tif (Array.isArray(value)) {\n\t\treturn value.map((x) => rebasePath(x, prependPath));\n\t} else {\n\t\treturn rebasePath(value as string, prependPath);\n\t}\n}\n\nfunction rebasePath(value: string, prependPath: string): string {\n\tif (path.isAbsolute(value)) {\n\t\treturn value;\n\t} else {\n\t\t// relative paths use posix syntax in tsconfig\n\t\treturn path.posix.normalize(path.posix.join(prependPath, value));\n\t}\n}\n\nexport interface TSConfckParseOptions {\n\t/**\n\t * optional cache map to speed up repeated parsing with multiple files\n\t * it is your own responsibility to clear the cache if tsconfig files change during its lifetime\n\t * cache keys are input `filename` and absolute paths to tsconfig.json files\n\t *\n\t * You must not modify cached values.\n\t */\n\tcache?: Map<string, TSConfckParseResult>;\n\n\t/**\n\t * treat missing tsconfig as empty result instead of an error\n\t * parse resolves with { filename: 'no_tsconfig_file_found',tsconfig:{}} instead of reject with error\n\t */\n\tresolveWithEmptyIfConfigNotFound?: boolean;\n}\n\nexport interface TSConfckParseResult {\n\t/**\n\t * absolute path to parsed tsconfig.json\n\t */\n\ttsconfigFile: string;\n\n\t/**\n\t * parsed result, including merged values from extended\n\t */\n\ttsconfig: any;\n\n\t/**\n\t * ParseResult for parent solution\n\t */\n\tsolution?: TSConfckParseResult;\n\n\t/**\n\t * ParseResults for all tsconfig files referenced in a solution\n\t */\n\treferenced?: TSConfckParseResult[];\n\n\t/**\n\t * ParseResult for all tsconfig files\n\t *\n\t * [a,b,c] where a extends b and b extends c\n\t */\n\textended?: TSConfckParseResult[];\n}\n\nexport class TSConfckParseError extends Error {\n\tconstructor(message: string, code: string, tsconfigFile: string, cause?: Error) {\n\t\tsuper(message);\n\t\t// Set the prototype explicitly.\n\t\tObject.setPrototypeOf(this, TSConfckParseError.prototype);\n\t\tthis.name = TSConfckParseError.name;\n\t\tthis.code = code;\n\t\tthis.cause = cause;\n\t\tthis.tsconfigFile = tsconfigFile;\n\t}\n\n\t/**\n\t * error code\n\t */\n\tcode: string;\n\t/**\n\t * the cause of this error\n\t */\n\tcause: Error | undefined;\n\n\t/**\n\t * absolute path of tsconfig file where the error happened\n\t */\n\ttsconfigFile: string;\n}\n", "import path from 'path';\nimport { promises as fs } from 'fs';\nimport { TSConfckParseResult } from './parse.js';\n\nconst POSIX_SEP_RE = new RegExp('\\\\' + path.posix.sep, 'g');\nconst NATIVE_SEP_RE = new RegExp('\\\\' + path.sep, 'g');\nconst PATTERN_REGEX_CACHE = new Map<string, RegExp>();\nconst GLOB_ALL_PATTERN = `**/*`;\nconst DEFAULT_EXTENSIONS = ['.ts', '.tsx', '.mts', '.cts'];\nconst DEFAULT_EXTENSIONS_RE_GROUP = `\\\\.(?:${DEFAULT_EXTENSIONS.map((ext) => ext.substring(1)).join(\n\t'|'\n)})`;\n// hide dynamic import from ts transform to prevent it turning into a require\n// see https://github.com/microsoft/TypeScript/issues/43329#issuecomment-811606238\nconst dynamicImportDefault = new Function('path', 'return import(path).then(m => m.default)');\n\nexport async function loadTS(): Promise<any> {\n\ttry {\n\t\treturn dynamicImportDefault('typescript');\n\t} catch (e) {\n\t\tconsole.error('typescript must be installed to use \"native\" functions');\n\t\tthrow e;\n\t}\n}\n\nexport async function resolveTSConfig(filename: string): Promise<string | void> {\n\tconst basename = path.basename(filename);\n\tif (basename !== 'tsconfig.json') {\n\t\treturn;\n\t}\n\tconst tsconfig = path.resolve(filename);\n\ttry {\n\t\tconst stat = await fs.stat(tsconfig);\n\t\tif (stat.isFile() || stat.isFIFO()) {\n\t\t\treturn tsconfig;\n\t\t}\n\t} catch (e) {\n\t\t// ignore does not exist error\n\t\tif (e.code !== 'ENOENT') {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tthrow new Error(`no tsconfig file found for ${filename}`);\n}\n\n/**\n * convert posix separator to native separator\n *\n * eg.\n * windows: C:/foo/bar -> c:\\foo\\bar\n * linux: /foo/bar -> /foo/bar\n *\n * @param filename {string} filename with posix separators\n * @returns {string} filename with native separators\n */\nexport function posix2native(filename: string) {\n\treturn path.posix.sep !== path.sep && filename.includes(path.posix.sep)\n\t\t? filename.replace(POSIX_SEP_RE, path.sep)\n\t\t: filename;\n}\n\n/**\n * convert native separator to posix separator\n *\n * eg.\n * windows: C:\\foo\\bar -> c:/foo/bar\n * linux: /foo/bar -> /foo/bar\n *\n * @param filename {string} filename with native separators\n * @returns {string} filename with posix separators\n */\nexport function native2posix(filename: string) {\n\treturn path.posix.sep !== path.sep && filename.includes(path.sep)\n\t\t? filename.replace(NATIVE_SEP_RE, path.posix.sep)\n\t\t: filename;\n}\n\n/**\n * converts params to native separator, resolves path and converts native back to posix\n *\n * needed on windows to handle posix paths in tsconfig\n *\n * @param dir {string} directory to resolve from\n * @param filename {string} filename or pattern to resolve\n */\nexport function resolve2posix(dir: string | null, filename: string) {\n\tif (path.sep === path.posix.sep) {\n\t\treturn dir ? path.resolve(dir, filename) : path.resolve(filename);\n\t}\n\treturn native2posix(\n\t\tdir\n\t\t\t? path.resolve(posix2native(dir), posix2native(filename))\n\t\t\t: path.resolve(posix2native(filename))\n\t);\n}\n\nexport function resolveReferencedTSConfigFiles(result: TSConfckParseResult): string[] {\n\tconst dir = path.dirname(result.tsconfigFile);\n\treturn result.tsconfig.references.map((ref: { path: string }) => {\n\t\tconst refPath = ref.path.endsWith('.json') ? ref.path : path.join(ref.path, 'tsconfig.json');\n\t\treturn resolve2posix(dir, refPath);\n\t});\n}\n\nexport function resolveSolutionTSConfig(\n\tfilename: string,\n\tresult: TSConfckParseResult\n): TSConfckParseResult {\n\tif (\n\t\tresult.referenced &&\n\t\tDEFAULT_EXTENSIONS.some((ext) => filename.endsWith(ext)) &&\n\t\t!isIncluded(filename, result)\n\t) {\n\t\tconst solutionTSConfig = result.referenced.find((referenced) =>\n\t\t\tisIncluded(filename, referenced)\n\t\t);\n\t\tif (solutionTSConfig) {\n\t\t\treturn {\n\t\t\t\t...solutionTSConfig,\n\t\t\t\tsolution: result\n\t\t\t};\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction isIncluded(filename: string, result: TSConfckParseResult): boolean {\n\tconst dir = native2posix(path.dirname(result.tsconfigFile));\n\tconst files = (result.tsconfig.files || []).map((file: string) => resolve2posix(dir, file));\n\tconst absoluteFilename = resolve2posix(null, filename);\n\tif (files.includes(filename)) {\n\t\treturn true;\n\t}\n\tconst isIncluded = isGlobMatch(\n\t\tabsoluteFilename,\n\t\tdir,\n\t\tresult.tsconfig.include || (result.tsconfig.files ? [] : [GLOB_ALL_PATTERN])\n\t);\n\tif (isIncluded) {\n\t\tconst isExcluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || []);\n\t\treturn !isExcluded;\n\t}\n\treturn false;\n}\n\n/**\n * test filenames agains glob patterns in tsconfig\n *\n * @param filename {string} posix style abolute path to filename to test\n * @param dir {string} posix style absolute path to directory of tsconfig containing patterns\n * @param patterns {string[]} glob patterns to match against\n * @returns {boolean} true when at least one pattern matches filename\n */\nexport function isGlobMatch(filename: string, dir: string, patterns: string[]): boolean {\n\treturn patterns.some((pattern) => {\n\t\t// filename must end with part of pattern that comes after last wildcard\n\t\tlet lastWildcardIndex = pattern.length;\n\t\tlet hasWildcard = false;\n\t\tfor (let i = pattern.length - 1; i > -1; i--) {\n\t\t\tif (pattern[i] === '*' || pattern[i] === '?') {\n\t\t\t\tlastWildcardIndex = i;\n\t\t\t\thasWildcard = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// if pattern does not end with wildcard, filename must end with pattern after last wildcard\n\t\tif (\n\t\t\tlastWildcardIndex < pattern.length - 1 &&\n\t\t\t!filename.endsWith(pattern.slice(lastWildcardIndex + 1))\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if pattern ends with *, filename must end with a default extension\n\t\tif (pattern.endsWith('*') && !DEFAULT_EXTENSIONS.some((ext) => filename.endsWith(ext))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// for **/* , filename must start with the dir\n\t\tif (pattern === GLOB_ALL_PATTERN) {\n\t\t\treturn filename.startsWith(`${dir}/`);\n\t\t}\n\n\t\tconst resolvedPattern = resolve2posix(dir, pattern);\n\n\t\t// filename must start with part of pattern that comes before first wildcard\n\t\tlet firstWildcardIndex = -1;\n\t\tfor (let i = 0; i < resolvedPattern.length; i++) {\n\t\t\tif (resolvedPattern[i] === '*' || resolvedPattern[i] === '?') {\n\t\t\t\tfirstWildcardIndex = i;\n\t\t\t\thasWildcard = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tfirstWildcardIndex > 1 &&\n\t\t\t!filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if no wildcard in pattern, filename must be equal to resolved pattern\n\t\tif (!hasWildcard) {\n\t\t\treturn filename === resolvedPattern;\n\t\t}\n\n\t\t// complex pattern, use regex to check it\n\t\tif (PATTERN_REGEX_CACHE.has(resolvedPattern)) {\n\t\t\treturn PATTERN_REGEX_CACHE.get(resolvedPattern)!.test(filename);\n\t\t}\n\t\tconst regex = pattern2regex(resolvedPattern);\n\t\tPATTERN_REGEX_CACHE.set(resolvedPattern, regex);\n\t\treturn regex.test(filename);\n\t});\n}\n\nfunction pattern2regex(resolvedPattern: string): RegExp {\n\tlet regexStr = '^';\n\tfor (let i = 0; i < resolvedPattern.length; i++) {\n\t\tconst char = resolvedPattern[i];\n\t\tif (char === '?') {\n\t\t\tregexStr += '[^\\\\/]';\n\t\t\tcontinue;\n\t\t}\n\t\tif (char === '*') {\n\t\t\tif (resolvedPattern[i + 1] === '*' && resolvedPattern[i + 2] === '/') {\n\t\t\t\ti += 2;\n\t\t\t\tregexStr += '(?:[^\\\\/]*\\\\/)*'; // zero or more path segments\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregexStr += '[^\\\\/]*';\n\t\t\tcontinue;\n\t\t}\n\t\tif ('/.+^${}()|[]\\\\'.includes(char)) {\n\t\t\tregexStr += `\\\\`;\n\t\t}\n\t\tregexStr += char;\n\t}\n\n\t// add known file endings if pattern ends on *\n\tif (resolvedPattern.endsWith('*')) {\n\t\tregexStr += DEFAULT_EXTENSIONS_RE_GROUP;\n\t}\n\tregexStr += '$';\n\n\treturn new RegExp(regexStr);\n}\n", "import path from 'path';\nimport { loadTS } from './util.js';\n\n/**\n * find the closest tsconfig.json file using native ts.findConfigFile\n *\n * You must have `typescript` installed to use this\n *\n * @param {string} filename - path to file to find tsconfig for (absolute or relative to cwd)\n * @returns {Promise<string>} absolute path to closest tsconfig.json\n */\nexport async function findNative(filename: string): Promise<string> {\n\tconst ts = await loadTS();\n\tconst { findConfigFile, sys } = ts;\n\tconst tsconfigFile = findConfigFile(path.dirname(path.resolve(filename)), sys.fileExists);\n\tif (!tsconfigFile) {\n\t\tthrow new Error(`no tsconfig file found for ${filename}`);\n\t}\n\treturn tsconfigFile;\n}\n", "import path from 'path';\nimport {\n\tloadTS,\n\tnative2posix,\n\tresolveReferencedTSConfigFiles,\n\tresolveSolutionTSConfig,\n\tresolveTSConfig\n} from './util';\nimport { findNative } from './find-native';\n\n/**\n * parse the closest tsconfig.json file with typescript native functions\n *\n * You need to have `typescript` installed to use this\n *\n * @param {string} filename - path to a tsconfig.json or a .ts source file (absolute or relative to cwd)\n * @param {TSConfckParseNativeOptions} options - options\n * @returns {Promise<TSConfckParseNativeResult>}\n * @throws {TSConfckParseNativeError}\n */\nexport async function parseNative(\n\tfilename: string,\n\toptions?: TSConfckParseNativeOptions\n): Promise<TSConfckParseNativeResult> {\n\tconst cache = options?.cache;\n\tif (cache?.has(filename)) {\n\t\treturn cache.get(filename)!;\n\t}\n\tlet tsconfigFile;\n\n\tif (options?.resolveWithEmptyIfConfigNotFound) {\n\t\ttry {\n\t\t\ttsconfigFile = await resolveTSConfig(filename);\n\t\t\tif (!tsconfigFile) {\n\t\t\t\ttsconfigFile = await findNative(filename);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconst notFoundResult = {\n\t\t\t\ttsconfigFile: 'no_tsconfig_file_found',\n\t\t\t\ttsconfig: {},\n\t\t\t\tresult: null\n\t\t\t};\n\t\t\tcache?.set(filename, notFoundResult);\n\t\t\treturn notFoundResult;\n\t\t}\n\t} else {\n\t\ttsconfigFile = await resolveTSConfig(filename);\n\t\tif (!tsconfigFile) {\n\t\t\ttsconfigFile = await findNative(filename);\n\t\t}\n\t}\n\n\tlet result: TSConfckParseNativeResult;\n\tif (cache?.has(tsconfigFile)) {\n\t\tresult = cache.get(tsconfigFile)!;\n\t} else {\n\t\tconst ts = await loadTS();\n\t\tresult = await parseFile(tsconfigFile, ts, options);\n\t\tawait parseReferences(result, ts, options);\n\t\tcache?.set(tsconfigFile, result);\n\t}\n\n\t//@ts-ignore\n\tresult = resolveSolutionTSConfig(filename, result);\n\t//@ts-ignore\n\tcache?.set(filename, result);\n\treturn result;\n}\n\nasync function parseFile(\n\ttsconfigFile: string,\n\tts: any,\n\toptions?: TSConfckParseNativeOptions\n): Promise<TSConfckParseNativeResult> {\n\tconst cache = options?.cache;\n\tif (cache?.has(tsconfigFile)) {\n\t\treturn cache.get(tsconfigFile)!;\n\t}\n\tconst posixTSConfigFile = native2posix(tsconfigFile);\n\tconst { parseJsonConfigFileContent, readConfigFile, sys } = ts;\n\tconst { config, error } = readConfigFile(posixTSConfigFile, sys.readFile);\n\tif (error) {\n\t\tthrow new TSConfckParseNativeError(error, tsconfigFile, null);\n\t}\n\n\tconst host = {\n\t\tuseCaseSensitiveFileNames: false,\n\t\treadDirectory: sys.readDirectory,\n\t\tfileExists: sys.fileExists,\n\t\treadFile: sys.readFile\n\t};\n\n\tif (options?.ignoreSourceFiles) {\n\t\tconfig.files = [];\n\t\tconfig.include = [];\n\t}\n\tconst nativeResult = parseJsonConfigFileContent(\n\t\tconfig,\n\t\thost,\n\t\tpath.dirname(posixTSConfigFile),\n\t\tundefined,\n\t\tposixTSConfigFile\n\t);\n\tcheckErrors(nativeResult, tsconfigFile);\n\n\tconst result: TSConfckParseNativeResult = {\n\t\ttsconfigFile,\n\t\ttsconfig: result2tsconfig(nativeResult, ts),\n\t\tresult: nativeResult\n\t};\n\tcache?.set(tsconfigFile, result);\n\treturn result;\n}\n\nasync function parseReferences(\n\tresult: TSConfckParseNativeResult,\n\tts: any,\n\toptions?: TSConfckParseNativeOptions\n) {\n\tif (!result.tsconfig.references) {\n\t\treturn;\n\t}\n\tconst referencedFiles = resolveReferencedTSConfigFiles(result);\n\tresult.referenced = await Promise.all(\n\t\treferencedFiles.map((file) => parseFile(file, ts, options))\n\t);\n}\n\n/**\n * check errors reported by parseJsonConfigFileContent\n *\n * ignores errors related to missing input files as these may happen regularly in programmatic use\n * and do not affect the config itself\n *\n * @param {nativeResult} any - native typescript parse result to check for errors\n * @throws {TSConfckParseNativeError} for critical error\n */\nfunction checkErrors(nativeResult: any, tsconfigFile: string) {\n\tconst ignoredErrorCodes = [\n\t\t// see https://github.com/microsoft/TypeScript/blob/main/src/compiler/diagnosticMessages.json\n\t\t18002, // empty files list\n\t\t18003 // no inputs\n\t];\n\tconst criticalError = nativeResult.errors?.find(\n\t\t(error: TSDiagnosticError) => error.category === 1 && !ignoredErrorCodes.includes(error.code)\n\t);\n\tif (criticalError) {\n\t\tthrow new TSConfckParseNativeError(criticalError, tsconfigFile, nativeResult);\n\t}\n}\n\n/**\n * convert the result of `parseJsonConfigFileContent` to a tsconfig that can be parsed again\n *\n * - use merged compilerOptions\n * - strip prefix and postfix of compilerOptions.lib\n * - convert enum values back to string\n *\n * @param result\n * @param ts typescript\n * @returns {object} tsconfig with merged compilerOptions and enums restored to their string form\n */\nfunction result2tsconfig(result: any, ts: any) {\n\t// dereference result.raw so changes below don't modify original\n\tconst tsconfig = JSON.parse(JSON.stringify(result.raw));\n\t// for some reason the extended compilerOptions are not available in result.raw but only in result.options\n\t// and contain an extra fields 'configFilePath' and 'pathsBasePath'. Use everything but those 2\n\tconst ignoredOptions = ['configFilePath', 'pathsBasePath'];\n\tif (result.options && Object.keys(result.options).some((o) => !ignoredOptions.includes(o))) {\n\t\ttsconfig.compilerOptions = {\n\t\t\t...result.options\n\t\t};\n\t\tfor (const ignored of ignoredOptions) {\n\t\t\tdelete tsconfig.compilerOptions[ignored];\n\t\t}\n\t}\n\n\tconst compilerOptions = tsconfig.compilerOptions;\n\tif (compilerOptions) {\n\t\tif (compilerOptions.lib != null) {\n\t\t\t// remove lib. and .dts from lib.es2019.d.ts etc\n\t\t\tcompilerOptions.lib = compilerOptions.lib.map((x: string) =>\n\t\t\t\tx.replace(/^lib\\./, '').replace(/\\.d\\.ts$/, '')\n\t\t\t);\n\t\t}\n\t\tconst enumProperties = [\n\t\t\t{ name: 'importsNotUsedAsValues', enumeration: ts.ImportsNotUsedAsValues },\n\t\t\t{ name: 'module', enumeration: ts.ModuleKind },\n\t\t\t{\n\t\t\t\tname: 'moduleResolution',\n\t\t\t\tenumeration: { 1: 'classic', 2: 'node' } /*ts.ModuleResolutionKind uses different names*/\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'newLine',\n\t\t\t\tenumeration: { 0: 'crlf', 1: 'lf' } /*ts.NewLineKind uses different names*/\n\t\t\t},\n\t\t\t{ name: 'target', enumeration: ts.ScriptTarget }\n\t\t];\n\t\tfor (const prop of enumProperties) {\n\t\t\tif (compilerOptions[prop.name] != null && typeof compilerOptions[prop.name] === 'number') {\n\t\t\t\tcompilerOptions[prop.name] = prop.enumeration[compilerOptions[prop.name]].toLowerCase();\n\t\t\t}\n\t\t}\n\t}\n\n\t// merged watchOptions\n\tif (result.watchOptions) {\n\t\ttsconfig.watchOptions = {\n\t\t\t...result.watchOptions\n\t\t};\n\t}\n\n\tconst watchOptions = tsconfig.watchOptions;\n\tif (watchOptions) {\n\t\tconst enumProperties = [\n\t\t\t{ name: 'watchFile', enumeration: ts.WatchFileKind },\n\t\t\t{ name: 'watchDirectory', enumeration: ts.WatchDirectoryKind },\n\t\t\t{ name: 'fallbackPolling', enumeration: ts.PollingWatchKind }\n\t\t];\n\t\tfor (const prop of enumProperties) {\n\t\t\tif (watchOptions[prop.name] != null && typeof watchOptions[prop.name] === 'number') {\n\t\t\t\tconst enumVal = prop.enumeration[watchOptions[prop.name]];\n\t\t\t\twatchOptions[prop.name] = enumVal.charAt(0).toLowerCase() + enumVal.slice(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (tsconfig.compileOnSave === false) {\n\t\t// ts adds this property even if it isn't present in the actual config\n\t\t// delete if it is false to match content of tsconfig\n\t\tdelete tsconfig.compileOnSave;\n\t}\n\treturn tsconfig;\n}\n\nexport interface TSConfckParseNativeOptions {\n\t/**\n\t * optional cache map to speed up repeated parsing with multiple files\n\t * it is your own responsibility to clear the cache if tsconfig files change during its lifetime\n\t * cache keys are input `filename` and absolute paths to tsconfig.json files\n\t *\n\t * You must not modify cached values.\n\t */\n\tcache?: Map<string, TSConfckParseNativeResult>;\n\n\t/**\n\t * treat missing tsconfig as empty result instead of an error\n\t * parseNative resolves with { filename: 'no_tsconfig_file_found',tsconfig:{}, result: null} instead of reject with error\n\t */\n\tresolveWithEmptyIfConfigNotFound?: boolean;\n\n\t/**\n\t * Set this option to true to force typescript to ignore all source files.\n\t *\n\t * This is faster - especially for large projects - but comes with 2 caveats\n\t *\n\t * 1) output tsconfig always has `files: [],include: []` instead of any real values configured.\n\t * 2) as a result of 1), it won't be able to resolve solution-style references and always return the closest tsconfig\n\t */\n\tignoreSourceFiles?: boolean;\n}\n\nexport interface TSConfckParseNativeResult {\n\t/**\n\t * absolute path to parsed tsconfig.json\n\t */\n\ttsconfigFile: string;\n\n\t/**\n\t * parsed result, including merged values from extended and normalized\n\t */\n\ttsconfig: any;\n\n\t/**\n\t * ParseResult for parent solution\n\t */\n\tsolution?: TSConfckParseNativeResult;\n\n\t/**\n\t * ParseNativeResults for all tsconfig files referenced in a solution\n\t */\n\treferenced?: TSConfckParseNativeResult[];\n\n\t/**\n\t * full output of ts.parseJsonConfigFileContent\n\t */\n\tresult: any;\n}\n\nexport class TSConfckParseNativeError extends Error {\n\tconstructor(diagnostic: TSDiagnosticError, tsconfigFile: string, result?: any) {\n\t\tsuper(diagnostic.messageText);\n\t\t// Set the prototype explicitly.\n\t\tObject.setPrototypeOf(this, TSConfckParseNativeError.prototype);\n\t\tthis.name = TSConfckParseNativeError.name;\n\t\tthis.code = `TS ${diagnostic.code}`;\n\t\tthis.diagnostic = diagnostic;\n\t\tthis.result = result;\n\t\tthis.tsconfigFile = tsconfigFile;\n\t}\n\n\t/**\n\t * code of typescript diagnostic, prefixed with \"TS \"\n\t */\n\tcode: string;\n\n\t/**\n\t * full ts diagnostic that caused this error\n\t */\n\tdiagnostic: any;\n\n\t/**\n\t * absolute path of tsconfig file where the error happened\n\t */\n\ttsconfigFile: string;\n\n\t/**\n\t * native result if present, contains all errors in result.errors\n\t */\n\tresult: any | undefined;\n}\n\ninterface TSDiagnosticError {\n\tcode: number;\n\tcategory: number;\n\tmessageText: string;\n\tstart?: number;\n}\n"],
  "mappings": "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",
  "names": []
}
