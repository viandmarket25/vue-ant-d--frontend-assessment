"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Worker = void 0;
const os_1 = __importDefault(require("os"));
const worker_threads_1 = require("worker_threads");
class Worker {
    constructor(fn, options = {}) {
        this.code = genWorkerCode(fn);
        this.max = options.max || Math.max(1, os_1.default.cpus().length - 1);
        this.pool = [];
        this.idlePool = [];
        this.queue = [];
    }
    async run(...args) {
        const worker = await this._getAvailableWorker();
        return new Promise((resolve, reject) => {
            worker.currentResolve = resolve;
            worker.currentReject = reject;
            worker.postMessage(args);
        });
    }
    stop() {
        this.pool.forEach((w) => w.unref());
        this.queue.forEach(([_, reject]) => reject(new Error('Main worker pool stopped before a worker was available.')));
        this.pool = [];
        this.idlePool = [];
        this.queue = [];
    }
    async _getAvailableWorker() {
        // has idle one?
        if (this.idlePool.length) {
            return this.idlePool.shift();
        }
        // can spawn more?
        if (this.pool.length < this.max) {
            const worker = new worker_threads_1.Worker(this.code, { eval: true });
            worker.on('message', (res) => {
                worker.currentResolve && worker.currentResolve(res);
                worker.currentResolve = null;
                this._assignDoneWorker(worker);
            });
            worker.on('error', (err) => {
                worker.currentReject && worker.currentReject(err);
                worker.currentReject = null;
            });
            worker.on('exit', (code) => {
                const i = this.pool.indexOf(worker);
                if (i > -1)
                    this.pool.splice(i, 1);
                if (code !== 0 && worker.currentReject) {
                    worker.currentReject(new Error(`Wroker stopped with non-0 exit code ${code}`));
                    worker.currentReject = null;
                }
            });
            this.pool.push(worker);
            return worker;
        }
        // no one is available, we have to wait
        let resolve;
        let reject;
        const onWorkerAvailablePromise = new Promise((r, rj) => {
            resolve = r;
            reject = rj;
        });
        this.queue.push([resolve, reject]);
        return onWorkerAvailablePromise;
    }
    _assignDoneWorker(worker) {
        // someone's waiting already?
        if (this.queue.length) {
            const [resolve] = this.queue.shift();
            resolve(worker);
            return;
        }
        // take a rest.
        this.idlePool.push(worker);
    }
}
exports.Worker = Worker;
function genWorkerCode(fn) {
    return `
const doWork = ${fn.toString()}

const { parentPort } = require('worker_threads')

parentPort.on('message', async (args) => {
  const res = await doWork(...args)
  parentPort.postMessage(res)
})
  `;
}
