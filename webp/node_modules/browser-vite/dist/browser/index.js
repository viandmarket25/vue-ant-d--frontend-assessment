import path, { join, extname } from 'path';
import fs, { promises } from 'fs';
import { URL, parse, pathToFileURL } from 'url';
import resolve from 'resolve';
import { builtinModules } from 'module';
import remapping from '@ampproject/remapping';
import * as acorn from 'acorn';
import { parse as parse$3 } from 'acorn';
import acornClassFields from 'acorn-class-fields';
import acornStaticClassFeatures from 'acorn-static-class-features';
import MagicString from 'magic-string';
import { dataToEsm, createFilter, makeLegalIdentifier } from '@rollup/pluginutils';
import { createHash } from 'crypto';
import { transform, formatMessages, build } from 'esbuild';
import { init, parse as parse$2 } from 'es-module-lexer';
import { resolve as resolve$1 } from 'resolve.exports';
import { performance } from 'perf_hooks';
import getEtag from 'etag';
import * as convertSourceMap from 'convert-source-map';
import { extract_names } from 'periscopic';
import { walk as walk$1 } from 'estree-walker';
import { isMatch } from 'micromatch';
import aliasPlugin from '@rollup/plugin-alias';
import { parse as parse$1, TSConfckParseError } from 'tsconfck';

const p = new Proxy(s=>s, { get() {return p;}});

const DEFAULT_MAIN_FIELDS = [
    'module',
    'jsnext:main',
    'jsnext'
];
const DEFAULT_EXTENSIONS = [
    '.mjs',
    '.js',
    '.ts',
    '.jsx',
    '.tsx',
    '.json'
];
const JS_TYPES_RE = /\.(?:j|t)sx?$|\.mjs$/;
const OPTIMIZABLE_ENTRY_RE = /\.(?:m?js|ts)$/;
const SPECIAL_QUERY_RE = /[\?&](?:worker|sharedworker|raw|url)\b/;
/**
 * Prefix for resolved fs paths, since windows paths may not be valid as URLs.
 */
const FS_PREFIX = `/@fs/`;
/**
 * Prefix for resolved Ids that are not valid browser import specifiers
 */
const VALID_ID_PREFIX = `/@id/`;
/**
 * Plugins that use 'virtual modules' (e.g. for helper functions), prefix the
 * module ID with `\0`, a convention from the rollup ecosystem.
 * This prevents other plugins from trying to process the id (like node resolution),
 * and core features like sourcemaps can use this info to differentiate between
 * virtual modules and regular files.
 * `\0` is not a permitted char in import URLs so we have to replace them during
 * import analysis. The id will be decoded back before entering the plugins pipeline.
 * These encoded virtual ids are also prefixed by the VALID_ID_PREFIX, so virtual
 * modules in the browser end up encoded as `/@id/__x00__{id}`
 */
const NULL_BYTE_PLACEHOLDER = `__x00__`;
const CLIENT_PUBLIC_PATH = `/@vite/client`;
// BROWSER VITE patch: disable require for browser build
// eslint-disable-next-line node/no-missing-require
const CLIENT_ENTRY = 'browser-vite/dist/client/client.mjs' ;
// eslint-disable-next-line node/no-missing-require
const ENV_ENTRY = 'browser-vite/dist/client/env.mjs' ;
const CLIENT_DIR = path.dirname(CLIENT_ENTRY);
// ** READ THIS ** before editing `KNOWN_ASSET_TYPES`.
//   If you add an asset to `KNOWN_ASSET_TYPES`, make sure to also add it
//   to the TypeScript declaration file `packages/vite/client.d.ts`.
const KNOWN_ASSET_TYPES = [
    // images
    'png',
    'jpe?g',
    'gif',
    'svg',
    'ico',
    'webp',
    'avif',
    // media
    'mp4',
    'webm',
    'ogg',
    'mp3',
    'wav',
    'flac',
    'aac',
    // fonts
    'woff2?',
    'eot',
    'ttf',
    'otf',
    // other
    'wasm',
    'webmanifest',
    'pdf'
];
const DEFAULT_ASSETS_RE = new RegExp(`\\.(` + KNOWN_ASSET_TYPES.join('|') + `)(\\?.*)?$`);
const DEP_VERSION_RE = /[\?&](v=[\w\.-]+)\b/;

// Strip valid id prefix. This is prepended to resolved Ids that are
// not valid browser import specifiers by the importAnalysis plugin.
function unwrapId(id) {
    return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length) : id;
}
const flattenId = (id) => id.replace(/(\s*>\s*)/g, '__').replace(/[\/\.]/g, '_');
//TODO: revisit later to see if the edge case that "compiling using node v12 code to be run in node v16 in the server" is what we intend to support.
const builtins = new Set([
    ...builtinModules,
    'assert/strict',
    'diagnostics_channel',
    'dns/promises',
    'fs/promises',
    'path/posix',
    'path/win32',
    'readline/promises',
    'stream/consumers',
    'stream/promises',
    'stream/web',
    'timers/promises',
    'util/types',
    'wasi'
]);
function isBuiltin(id) {
    return builtins.has(id.replace(/^node:/, ''));
}
function moduleListContains(moduleList, id) {
    return moduleList === null || moduleList === void 0 ? void 0 : moduleList.some((m) => m === id || id.startsWith(m + '/'));
}
const bareImportRE = /^[\w@](?!.*:\/\/)/;
let isRunningWithYarnPnp;
try {
    isRunningWithYarnPnp = Boolean(undefined);
}
catch { }
const ssrExtensions = ['.js', '.cjs', '.json', '.node'];
function resolveFrom(id, basedir, preserveSymlinks = false, ssr = false) {
    return resolve.sync(id, {
        basedir,
        extensions: ssr ? ssrExtensions : DEFAULT_EXTENSIONS,
        // necessary to work with pnpm
        preserveSymlinks: preserveSymlinks || isRunningWithYarnPnp || false
    });
}
/**
 * like `resolveFrom` but supports resolving `>` path in `id`,
 * for example: `foo > bar > baz`
 */
function nestedResolveFrom(id, basedir, preserveSymlinks = false) {
    const pkgs = id.split('>').map((pkg) => pkg.trim());
    try {
        for (const pkg of pkgs) {
            basedir = resolveFrom(pkg, basedir, preserveSymlinks);
        }
    }
    catch { }
    return basedir;
}
// set in bin/vite.js
const filter = process.env.VITE_DEBUG_FILTER;
const DEBUG = false;
function createDebugger(namespace, options = {}) {
    const { onlyWhenFocused } = options;
    const focus = typeof onlyWhenFocused === 'string' ? onlyWhenFocused : namespace;
    return (msg, ...args) => {
        if (filter && !msg.includes(filter)) {
            return;
        }
        if (onlyWhenFocused && !(DEBUG.includes(focus))) {
            return;
        }
    };
}
const VOLUME_RE = /^[A-Z]:/i;
function normalizePath(id) {
    return path.posix.normalize(id);
}
function fsPathFromId(id) {
    const fsPath = normalizePath(id.slice(FS_PREFIX.length));
    return fsPath.startsWith('/') || fsPath.match(VOLUME_RE)
        ? fsPath
        : `/${fsPath}`;
}
function ensureVolumeInPath(file) {
    return file;
}
const queryRE = /\?.*$/s;
const hashRE = /#.*$/s;
const cleanUrl = (url) => url.replace(hashRE, '').replace(queryRE, '');
const externalRE = /^(https?:)?\/\//;
const isExternalUrl = (url) => externalRE.test(url);
const dataUrlRE = /^\s*data:/i;
const isDataUrl = (url) => dataUrlRE.test(url);
const virtualModuleRE = /^virtual-module:.*/;
const virtualModulePrefix = 'virtual-module:';
const knownJsSrcRE = /\.((j|t)sx?|mjs|vue|marko|svelte|astro)($|\?)/;
const isJSRequest = (url) => {
    url = cleanUrl(url);
    if (knownJsSrcRE.test(url)) {
        return true;
    }
    if (!path.extname(url) && !url.endsWith('/')) {
        return true;
    }
    return false;
};
const knownTsRE = /\.(ts|mts|cts|tsx)$/;
const knownTsOutputRE = /\.(js|mjs|cjs|jsx)$/;
const isTsRequest = (url) => knownTsRE.test(cleanUrl(url));
const isPossibleTsOutput = (url) => knownTsOutputRE.test(cleanUrl(url));
const getTsSrcPath = (filename) => filename.replace(/\.([cm])?(js)(x?)(\?|$)/, '.$1ts$3');
const importQueryRE = /(\?|&)import=?(?:&|$)/;
const trailingSeparatorRE = /[\?&]$/;
function removeImportQuery(url) {
    return url.replace(importQueryRE, '$1').replace(trailingSeparatorRE, '');
}
function injectQuery(url, queryToInject) {
    // encode percents for consistent behavior with pathToFileURL
    // see #2614 for details
    // BROWSER VITE patch: fix logic for browser URL support
    let resolvedUrl = new URL(url.replace(/%/g, '%25'), 'file:///');
    // if (resolvedUrl.protocol !== 'relative:') {
    //   resolvedUrl = pathToFileURL(url)
    // }
    let { pathname, search, hash } = resolvedUrl;
    // if (protocol === 'file:') {
    //   pathname = pathname.slice(1)
    // }
    pathname = decodeURIComponent(pathname);
    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;
}
const timestampRE = /\bt=\d{13}&?\b/;
function removeTimestampQuery(url) {
    return url.replace(timestampRE, '').replace(trailingSeparatorRE, '');
}
async function asyncReplace(input, re, replacer) {
    let match;
    let remaining = input;
    let rewritten = '';
    while ((match = re.exec(remaining))) {
        rewritten += remaining.slice(0, match.index);
        rewritten += await replacer(match);
        remaining = remaining.slice(match.index + match[0].length);
    }
    rewritten += remaining;
    return rewritten;
}
/**
 * pretty url for logging.
 */
function prettifyUrl(url, root) {
    url = removeTimestampQuery(url);
    const isAbsoluteFile = url.startsWith(root);
    if (isAbsoluteFile || url.startsWith(FS_PREFIX)) {
        let file = path.relative(root, isAbsoluteFile ? url : fsPathFromId(url));
        const seg = file.split('/');
        const npmIndex = seg.indexOf(`node_modules`);
        const isSourceMap = file.endsWith('.map');
        if (npmIndex > 0) {
            file = seg[npmIndex + 1];
            if (file.startsWith('@')) {
                file = `${file}/${seg[npmIndex + 2]}`;
            }
            file = `npm: ${p.dim(file)}${isSourceMap ? ` (source map)` : ``}`;
        }
        return p.dim(file);
    }
    else {
        return p.dim(url);
    }
}
function isObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}
function isDefined(value) {
    return value != null;
}
function lookupFile(dir, formats, pathOnly = false) {
    for (const format of formats) {
        const fullPath = path.join(dir, format);
        if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {
            return pathOnly ? fullPath : fs.readFileSync(fullPath, 'utf-8');
        }
    }
    const parentDir = path.dirname(dir);
    if (parentDir !== dir) {
        return lookupFile(parentDir, formats, pathOnly);
    }
}
const splitRE = /\r?\n/;
const range = 2;
function pad(source, n = 2) {
    const lines = source.split(splitRE);
    return lines.map((l) => ` `.repeat(n) + l).join(`\n`);
}
function posToNumber(source, pos) {
    if (typeof pos === 'number')
        return pos;
    const lines = source.split(splitRE);
    const { line, column } = pos;
    let start = 0;
    for (let i = 0; i < line - 1; i++) {
        start += lines[i].length + 1;
    }
    return start + column;
}
function numberToPos(source, offset) {
    if (typeof offset !== 'number')
        return offset;
    if (offset > source.length) {
        throw new Error(`offset is longer than source length! offset ${offset} > length ${source.length}`);
    }
    const lines = source.split(splitRE);
    let counted = 0;
    let line = 0;
    let column = 0;
    for (; line < lines.length; line++) {
        const lineLength = lines[line].length + 1;
        if (counted + lineLength >= offset) {
            column = offset - counted + 1;
            break;
        }
        counted += lineLength;
    }
    return { line: line + 1, column };
}
function generateCodeFrame(source, start = 0, end) {
    start = posToNumber(source, start);
    end = end || start;
    const lines = source.split(splitRE);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}
/**
 * Use instead of fs.existsSync(filename)
 * #2051 if we don't have read permission on a directory, existsSync() still
 * works and will result in massively slow subsequent checks (which are
 * unnecessary in the first place)
 */
function isFileReadable(filename) {
    try {
        fs.accessSync(filename, fs.constants.R_OK);
        return true;
    }
    catch {
        return false;
    }
}
function ensureLeadingSlash(path) {
    return !path.startsWith('/') ? '/' + path : path;
}
function ensureWatchedFile(watcher, file, root) {
    if (file &&
        // only need to watch if out of root
        !file.startsWith(root + '/') &&
        // some rollup plugins use null bytes for private resolved Ids
        !file.includes('\0') &&
        fs.existsSync(file)) {
        // resolve file to normalized system path
        watcher.add(path.resolve(file));
    }
}
const escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
async function processSrcSet(srcs, replacer) {
    const imageCandidates = srcs
        .split(',')
        .map((s) => {
        const [url, descriptor] = s
            .replace(escapedSpaceCharacters, ' ')
            .trim()
            .split(' ', 2);
        return { url, descriptor };
    })
        .filter(({ url }) => !!url);
    const ret = await Promise.all(imageCandidates.map(async ({ url, descriptor }) => {
        return {
            url: await replacer({ url, descriptor }),
            descriptor
        };
    }));
    return ret.reduce((prev, { url, descriptor }, index) => {
        descriptor = descriptor || '';
        return (prev +=
            url + ` ${descriptor}${index === ret.length - 1 ? '' : ', '}`);
    }, '');
}
// based on https://github.com/sveltejs/svelte/blob/abf11bb02b2afbd3e4cac509a0f70e318c306364/src/compiler/utils/mapped_code.ts#L221
const nullSourceMap = {
    names: [],
    sources: [],
    mappings: '',
    version: 3
};
function combineSourcemaps(filename, sourcemapList) {
    if (sourcemapList.length === 0 ||
        sourcemapList.every((m) => m.sources.length === 0)) {
        return { ...nullSourceMap };
    }
    // We don't declare type here so we can convert/fake/map as RawSourceMap
    let map; //: SourceMap
    let mapIndex = 1;
    const useArrayInterface = sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === undefined;
    if (useArrayInterface) {
        map = remapping(sourcemapList, () => null, true);
    }
    else {
        map = remapping(sourcemapList[0], function loader(sourcefile) {
            if (sourcefile === filename && sourcemapList[mapIndex]) {
                return sourcemapList[mapIndex++];
            }
            else {
                return { ...nullSourceMap };
            }
        }, true);
    }
    if (!map.file) {
        delete map.file;
    }
    return map;
}
function toUpperCaseDriveLetter(pathName) {
    return pathName.replace(/^\w:/, (letter) => letter.toUpperCase());
}
const multilineCommentsRE = /\/\*(.|[\r\n])*?\*\//gm;
const singlelineCommentsRE = /\/\/.*/g;
const usingDynamicImport = typeof jest === 'undefined';
/**
 * Dynamically import files. It will make sure it's not being compiled away by TS/Rollup.
 *
 * As a temporary workaround for Jest's lack of stable ESM support, we fallback to require
 * if we're in a Jest environment.
 * See https://github.com/vitejs/vite/pull/5197#issuecomment-938054077
 *
 * @param file File path to import.
 */
usingDynamicImport
    ? new Function('file', 'return import(file)')
    : require;

/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime$1() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime$1.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime$1.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime$1.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

var Mime_1 = Mime$1;

var standard = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["es","ecma"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/express":["exp"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/trig":["trig"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/step+xml":["stpx"],"model/step+zip":["stpz"],"model/step-xml+zip":["stpxz"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

let Mime = Mime_1;
var lite = new Mime(standard);

const assetUrlRE = /__VITE_ASSET__([a-z\d]{8})__(?:\$_(.*?)__)?/g;
const rawRE = /(\?|&)raw(?:&|$)/;
const urlRE = /(\?|&)url(?:&|$)/;
const chunkToEmittedAssetsMap = new WeakMap();
const assetCache = new WeakMap();
const assetHashToFilenameMap = new WeakMap();
// save hashes of the files that has been emitted in build watch
const emittedHashMap = new WeakMap();
/**
 * Also supports loading plain strings with import text from './foo.txt?raw'
 */
function assetPlugin(config) {
    // assetHashToFilenameMap initialization in buildStart causes getAssetFilename to return undefined
    assetHashToFilenameMap.set(config, new Map());
    return {
        name: 'vite:asset',
        buildStart() {
            assetCache.set(config, new Map());
            emittedHashMap.set(config, new Set());
        },
        resolveId(id) {
            if (!config.assetsInclude(cleanUrl(id))) {
                return;
            }
            // imports to absolute urls pointing to files in /public
            // will fail to resolve in the main resolver. handle them here.
            const publicFile = checkPublicFile(id, config);
            if (publicFile) {
                return id;
            }
        },
        async load(id) {
            if (id.startsWith('\0')) {
                // Rollup convention, this id should be handled by the
                // plugin that marked it with \0
                return;
            }
            // raw requests, read from disk
            if (rawRE.test(id)) {
                const file = checkPublicFile(id, config) || cleanUrl(id);
                // raw query, read file and return as string
                return `export default ${JSON.stringify(await promises.readFile(file, 'utf-8'))}`;
            }
            if (!config.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) {
                return;
            }
            id = id.replace(urlRE, '$1').replace(/[\?&]$/, '');
            const url = await fileToUrl(id, config, this);
            return `export default ${JSON.stringify(url)}`;
        },
        renderChunk(code, chunk) {
            let match;
            let s;
            // Urls added with JS using e.g.
            // imgElement.src = "my/file.png" are using quotes
            // Urls added in CSS that is imported in JS end up like
            // var inlined = ".inlined{color:green;background:url(__VITE_ASSET__5aa0ddc0__)}\n";
            // In both cases, the wrapping should already be fine
            while ((match = assetUrlRE.exec(code))) {
                s = s || (s = new MagicString(code));
                const [full, hash, postfix = ''] = match;
                // some internal plugins may still need to emit chunks (e.g. worker) so
                // fallback to this.getFileName for that.
                const file = getAssetFilename(hash, config) || this.getFileName(hash);
                registerAssetToChunk(chunk, file);
                const outputFilepath = config.base + file + postfix;
                s.overwrite(match.index, match.index + full.length, outputFilepath);
            }
            if (s) {
                return {
                    code: s.toString(),
                    map: config.build.sourcemap ? s.generateMap({ hires: true }) : null
                };
            }
            else {
                return null;
            }
        },
        generateBundle(_, bundle) {
            // do not emit assets for SSR build
            if (config.command === 'build' && config.build.ssr) {
                for (const file in bundle) {
                    if (bundle[file].type === 'asset' &&
                        !file.includes('ssr-manifest.json')) {
                        delete bundle[file];
                    }
                }
            }
        }
    };
}
function registerAssetToChunk(chunk, file) {
    let emitted = chunkToEmittedAssetsMap.get(chunk);
    if (!emitted) {
        emitted = new Set();
        chunkToEmittedAssetsMap.set(chunk, emitted);
    }
    emitted.add(cleanUrl(file));
}
function checkPublicFile(url, { publicDir }) {
    // note if the file is in /public, the resolver would have returned it
    // as-is so it's not going to be a fully resolved path.
    if (!publicDir || !url.startsWith('/')) {
        return;
    }
    const publicFile = path.join(publicDir, cleanUrl(url));
    if (fs.existsSync(publicFile)) {
        return publicFile;
    }
    else {
        return;
    }
}
function fileToUrl(id, config, ctx) {
    if (config.command === 'serve') {
        return fileToDevUrl(id, config);
    }
    else {
        return fileToBuiltUrl(id, config, ctx);
    }
}
function fileToDevUrl(id, config) {
    var _a, _b;
    let rtn;
    if (checkPublicFile(id, config)) {
        // in public dir, keep the url as-is
        rtn = id;
    }
    else if (id.startsWith(config.root)) {
        // in project root, infer short public path
        rtn = '/' + path.posix.relative(config.root, id);
    }
    else {
        // outside of project root, use absolute fs path
        // (this is special handled by the serve static middleware
        rtn = path.posix.join(FS_PREFIX + id);
    }
    const origin = (_b = (_a = config.server) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : '';
    return origin + config.base + rtn.replace(/^\//, '');
}
function getAssetFilename(hash, config) {
    var _a;
    return (_a = assetHashToFilenameMap.get(config)) === null || _a === void 0 ? void 0 : _a.get(hash);
}
/**
 * converts the source filepath of the asset to the output filename based on the assetFileNames option. \
 * this function imitates the behavior of rollup.js. \
 * https://rollupjs.org/guide/en/#outputassetfilenames
 *
 * @example
 * ```ts
 * const content = Buffer.from('text');
 * const fileName = assetFileNamesToFileName(
 *   'assets/[name].[hash][extname]',
 *   '/path/to/file.txt',
 *   getAssetHash(content),
 *   content
 * )
 * // fileName: 'assets/file.982d9e3e.txt'
 * ```
 *
 * @param assetFileNames filename pattern. e.g. `'assets/[name].[hash][extname]'`
 * @param file filepath of the asset
 * @param contentHash hash of the asset. used for `'[hash]'` placeholder
 * @param content content of the asset. passed to `assetFileNames` if `assetFileNames` is a function
 * @returns output filename
 */
function assetFileNamesToFileName(assetFileNames, file, contentHash, content) {
    const basename = path.basename(file);
    // placeholders for `assetFileNames`
    // `hash` is slightly different from the rollup's one
    const extname = path.extname(basename);
    const ext = extname.substring(1);
    const name = basename.slice(0, -extname.length);
    const hash = contentHash;
    if (typeof assetFileNames === 'function') {
        assetFileNames = assetFileNames({
            name: file,
            source: content,
            type: 'asset'
        });
        if (typeof assetFileNames !== 'string') {
            throw new TypeError('assetFileNames must return a string');
        }
    }
    else if (typeof assetFileNames !== 'string') {
        throw new TypeError('assetFileNames must be a string or a function');
    }
    const fileName = assetFileNames.replace(/\[\w+\]/g, (placeholder) => {
        switch (placeholder) {
            case '[ext]':
                return ext;
            case '[extname]':
                return extname;
            case '[hash]':
                return hash;
            case '[name]':
                return name;
        }
        throw new Error(`invalid placeholder ${placeholder} in assetFileNames "${assetFileNames}"`);
    });
    return fileName;
}
/**
 * Register an asset to be emitted as part of the bundle (if necessary)
 * and returns the resolved public URL
 */
async function fileToBuiltUrl(id, config, pluginContext, skipPublicCheck = false) {
    var _a, _b, _c;
    if (!skipPublicCheck && checkPublicFile(id, config)) {
        return config.base + id.slice(1);
    }
    const cache = assetCache.get(config);
    const cached = cache.get(id);
    if (cached) {
        return cached;
    }
    const file = cleanUrl(id);
    const content = await promises.readFile(file);
    let url;
    if (config.build.lib ||
        (!file.endsWith('.svg') &&
            content.length < Number(config.build.assetsInlineLimit))) {
        // base64 inlined as a string
        url = `data:${lite.getType(file)};base64,${content.toString('base64')}`;
    }
    else {
        // emit as asset
        // rollup supports `import.meta.ROLLUP_FILE_URL_*`, but it generates code
        // that uses runtime url sniffing and it can be verbose when targeting
        // non-module format. It also fails to cascade the asset content change
        // into the chunk's hash, so we have to do our own content hashing here.
        // https://bundlers.tooling.report/hashing/asset-cascade/
        // https://github.com/rollup/rollup/issues/3415
        const map = assetHashToFilenameMap.get(config);
        const contentHash = getAssetHash(content);
        const { search, hash } = parse(id);
        const postfix = (search || '') + (hash || '');
        const output = (_b = (_a = config.build) === null || _a === void 0 ? void 0 : _a.rollupOptions) === null || _b === void 0 ? void 0 : _b.output;
        const assetFileNames = (_c = (output && !Array.isArray(output) ? output.assetFileNames : undefined)) !== null && _c !== void 0 ? _c : 
        // defaults to '<assetsDir>/[name].[hash][extname]'
        // slightly different from rollup's one ('assets/[name]-[hash][extname]')
        path.posix.join(config.build.assetsDir, '[name].[hash][extname]');
        const fileName = assetFileNamesToFileName(assetFileNames, file, contentHash, content);
        if (!map.has(contentHash)) {
            map.set(contentHash, fileName);
        }
        const emittedSet = emittedHashMap.get(config);
        if (!emittedSet.has(contentHash)) {
            const name = normalizePath(path.relative(config.root, file));
            pluginContext.emitFile({
                name,
                fileName,
                type: 'asset',
                source: content
            });
            emittedSet.add(contentHash);
        }
        url = `__VITE_ASSET__${contentHash}__${postfix ? `$_${postfix}__` : ``}`;
    }
    cache.set(id, url);
    return url;
}
function getAssetHash(content) {
    return createHash('sha256').update(content).digest('hex').slice(0, 8);
}

var glob = { sync: () => [] };

var postcssrc = () => {throw new Error("No PostCSS Config found")};

const cssLangs = `\\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\\?)`;
const cssLangRE = new RegExp(cssLangs);
const cssModuleRE = new RegExp(`\\.module${cssLangs}`);
const directRequestRE = /(\?|&)direct\b/;
const commonjsProxyRE = /\?commonjs-proxy/;
const inlineRE = /(\?|&)inline\b/;
const usedRE = /(\?|&)used\b/;
const isCSSRequest = (request) => cssLangRE.test(request);
const isDirectCSSRequest = (request) => cssLangRE.test(request) && directRequestRE.test(request);
const cssModulesCache = new WeakMap();
const chunkToEmittedCssFileMap = new WeakMap();
const removedPureCssFilesCache = new WeakMap();
const postcssConfigCache = new WeakMap();
/**
 * Plugin applied before user plugins
 */
function cssPlugin(config) {
    let server;
    let moduleCache;
    const resolveUrl = config.createResolver({
        preferRelative: true,
        tryIndex: false,
        extensions: []
    });
    const atImportResolvers = createCSSResolvers(config);
    return {
        name: 'vite:css',
        configureServer(_server) {
            server = _server;
        },
        buildStart() {
            // Ensure a new cache for every build (i.e. rebuilding in watch mode)
            moduleCache = new Map();
            cssModulesCache.set(config, moduleCache);
            removedPureCssFilesCache.set(config, new Map());
        },
        async transform(raw, id, options) {
            var _a, _b;
            if (!isCSSRequest(id) || commonjsProxyRE.test(id)) {
                return;
            }
            const ssr = (options === null || options === void 0 ? void 0 : options.ssr) === true;
            const urlReplacer = async (url, importer) => {
                if (checkPublicFile(url, config)) {
                    return config.base + url.slice(1);
                }
                const resolved = await resolveUrl(url, importer);
                if (resolved) {
                    return fileToUrl(resolved, config, this);
                }
                return url;
            };
            const { code: css, modules, deps } = await compileCSS(id, raw, config, urlReplacer, atImportResolvers, server);
            if (modules) {
                moduleCache.set(id, modules);
            }
            // track deps for build watch mode
            if (config.command === 'build' && config.build.watch && deps) {
                for (const file of deps) {
                    this.addWatchFile(file);
                }
            }
            // dev
            if (server) {
                // server only logic for handling CSS @import dependency hmr
                const { moduleGraph } = server;
                const thisModule = moduleGraph.getModuleById(id);
                if (thisModule) {
                    // CSS modules cannot self-accept since it exports values
                    const isSelfAccepting = !modules && !inlineRE.test(id);
                    if (deps) {
                        // record deps in the module graph so edits to @import css can trigger
                        // main import to hot update
                        const depModules = new Set();
                        for (const file of deps) {
                            depModules.add(isCSSRequest(file)
                                ? moduleGraph.createFileOnlyEntry(file)
                                : await moduleGraph.ensureEntryFromUrl((await fileToUrl(file, config, this)).replace(((_b = (_a = config.server) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : '') + config.base, '/'), ssr));
                        }
                        moduleGraph.updateModuleInfo(thisModule, depModules, 
                        // The root CSS proxy module is self-accepting and should not
                        // have an explicit accept list
                        new Set(), isSelfAccepting, ssr);
                        for (const file of deps) {
                            this.addWatchFile(file);
                        }
                    }
                    else {
                        thisModule.isSelfAccepting = isSelfAccepting;
                    }
                }
            }
            return {
                code: css,
                // TODO CSS source map
                map: { mappings: '' }
            };
        }
    };
}
/**
 * Plugin applied after user plugins
 */
function cssPostPlugin(config) {
    // styles initialization in buildStart causes a styling loss in watch
    const styles = new Map();
    let pureCssChunks;
    // when there are multiple rollup outputs and extracting CSS, only emit once,
    // since output formats have no effect on the generated CSS.
    let outputToExtractedCSSMap;
    let hasEmitted = false;
    return {
        name: 'vite:css-post',
        buildStart() {
            // Ensure new caches for every build (i.e. rebuilding in watch mode)
            pureCssChunks = new Set();
            outputToExtractedCSSMap = new Map();
            hasEmitted = false;
        },
        async transform(css, id, options) {
            if (!isCSSRequest(id) || commonjsProxyRE.test(id)) {
                return;
            }
            const inlined = inlineRE.test(id);
            const modules = cssModulesCache.get(config).get(id);
            const modulesCode = modules && dataToEsm(modules, { namedExports: true, preferConst: true });
            if (config.command === 'serve') {
                if (isDirectCSSRequest(id)) {
                    return css;
                }
                else {
                    // server only
                    if (options === null || options === void 0 ? void 0 : options.ssr) {
                        return modulesCode || `export default ${JSON.stringify(css)}`;
                    }
                    if (inlined) {
                        return `export default ${JSON.stringify(css)}`;
                    }
                    return [
                        `import { updateStyle, removeStyle } from ${JSON.stringify(path.posix.join(config.base, CLIENT_PUBLIC_PATH))}`,
                        `const id = ${JSON.stringify(id)}`,
                        `const css = ${JSON.stringify(css)}`,
                        `updateStyle(id, css)`,
                        // css modules exports change on edit so it can't self accept
                        `${modulesCode || `import.meta.hot.accept()\nexport default css`}`,
                        `import.meta.hot.prune(() => removeStyle(id))`
                    ].join('\n');
                }
            }
            // build CSS handling ----------------------------------------------------
            // record css
            if (!inlined) {
                styles.set(id, css);
            }
            return {
                code: modulesCode ||
                    (usedRE.test(id)
                        ? `export default ${JSON.stringify(inlined ? await minifyCSS(css, config) : css)}`
                        : `export default ''`),
                map: { mappings: '' },
                // avoid the css module from being tree-shaken so that we can retrieve
                // it in renderChunk()
                moduleSideEffects: inlined ? false : 'no-treeshake'
            };
        },
        async renderChunk(code, chunk, opts) {
            let chunkCSS = '';
            let isPureCssChunk = true;
            const ids = Object.keys(chunk.modules);
            for (const id of ids) {
                if (!isCSSRequest(id) ||
                    cssModuleRE.test(id) ||
                    commonjsProxyRE.test(id)) {
                    isPureCssChunk = false;
                }
                if (styles.has(id)) {
                    chunkCSS += styles.get(id);
                }
            }
            if (!chunkCSS) {
                return null;
            }
            // resolve asset URL placeholders to their built file URLs and perform
            // minification if necessary
            const processChunkCSS = async (css, { inlined, minify }) => {
                // replace asset url references with resolved url.
                const isRelativeBase = config.base === '' || config.base.startsWith('.');
                css = css.replace(assetUrlRE, (_, fileHash, postfix = '') => {
                    const filename = getAssetFilename(fileHash, config) + postfix;
                    registerAssetToChunk(chunk, filename);
                    if (!isRelativeBase || inlined) {
                        // absolute base or relative base but inlined (injected as style tag into
                        // index.html) use the base as-is
                        return config.base + filename;
                    }
                    else {
                        // relative base + extracted CSS - asset file will be in the same dir
                        return `./${path.posix.basename(filename)}`;
                    }
                });
                // only external @imports should exist at this point - and they need to
                // be hoisted to the top of the CSS chunk per spec (#1845)
                if (css.includes('@import')) {
                    css = await hoistAtImports(css);
                }
                if (minify && config.build.minify) {
                    css = await minifyCSS(css, config);
                }
                return css;
            };
            if (config.build.cssCodeSplit) {
                if (isPureCssChunk) {
                    // this is a shared CSS-only chunk that is empty.
                    pureCssChunks.add(chunk.fileName);
                }
                if (opts.format === 'es' || opts.format === 'cjs') {
                    chunkCSS = await processChunkCSS(chunkCSS, {
                        inlined: false,
                        minify: true
                    });
                    // emit corresponding css file
                    const fileHandle = this.emitFile({
                        name: chunk.name + '.css',
                        type: 'asset',
                        source: chunkCSS
                    });
                    chunkToEmittedCssFileMap.set(chunk, new Set([this.getFileName(fileHandle)]));
                }
                else if (!config.build.ssr) {
                    // legacy build, inline css
                    chunkCSS = await processChunkCSS(chunkCSS, {
                        inlined: true,
                        minify: true
                    });
                    const style = `__vite_style__`;
                    const injectCode = `var ${style} = document.createElement('style');` +
                        `${style}.innerHTML = ${JSON.stringify(chunkCSS)};` +
                        `document.head.appendChild(${style});`;
                    if (config.build.sourcemap) {
                        const s = new MagicString(code);
                        s.prepend(injectCode);
                        return {
                            code: s.toString(),
                            map: s.generateMap({ hires: true })
                        };
                    }
                    else {
                        return { code: injectCode + code };
                    }
                }
            }
            else {
                // non-split extracted CSS will be minified together
                chunkCSS = await processChunkCSS(chunkCSS, {
                    inlined: false,
                    minify: false
                });
                outputToExtractedCSSMap.set(opts, (outputToExtractedCSSMap.get(opts) || '') + chunkCSS);
            }
            return null;
        },
        async generateBundle(opts, bundle) {
            // remove empty css chunks and their imports
            if (pureCssChunks.size) {
                const emptyChunkFiles = [...pureCssChunks]
                    .map((file) => path.basename(file))
                    .join('|')
                    .replace(/\./g, '\\.');
                const emptyChunkRE = new RegExp(opts.format === 'es'
                    ? `\\bimport\\s*"[^"]*(?:${emptyChunkFiles})";\n?`
                    : `\\brequire\\(\\s*"[^"]*(?:${emptyChunkFiles})"\\);\n?`, 'g');
                for (const file in bundle) {
                    const chunk = bundle[file];
                    if (chunk.type === 'chunk') {
                        // remove pure css chunk from other chunk's imports,
                        // and also register the emitted CSS files under the importer
                        // chunks instead.
                        chunk.imports = chunk.imports.filter((file) => {
                            if (pureCssChunks.has(file)) {
                                const css = chunkToEmittedCssFileMap.get(bundle[file]);
                                if (css) {
                                    let existing = chunkToEmittedCssFileMap.get(chunk);
                                    if (!existing) {
                                        existing = new Set();
                                    }
                                    css.forEach((file) => existing.add(file));
                                    chunkToEmittedCssFileMap.set(chunk, existing);
                                }
                                return false;
                            }
                            return true;
                        });
                        chunk.code = chunk.code.replace(emptyChunkRE, 
                        // remove css import while preserving source map location
                        (m) => `/* empty css ${''.padEnd(m.length - 15)}*/`);
                    }
                }
                const removedPureCssFiles = removedPureCssFilesCache.get(config);
                pureCssChunks.forEach((fileName) => {
                    removedPureCssFiles.set(fileName, bundle[fileName]);
                    delete bundle[fileName];
                });
            }
            let extractedCss = outputToExtractedCSSMap.get(opts);
            if (extractedCss && !hasEmitted) {
                hasEmitted = true;
                // minify css
                if (config.build.minify) {
                    extractedCss = await minifyCSS(extractedCss, config);
                }
                this.emitFile({
                    name: 'style.css',
                    type: 'asset',
                    source: extractedCss
                });
            }
        }
    };
}
function createCSSResolvers(config) {
    let cssResolve;
    let sassResolve;
    let lessResolve;
    return {
        get css() {
            return (cssResolve ||
                (cssResolve = config.createResolver({
                    extensions: ['.css'],
                    mainFields: ['style'],
                    tryIndex: false,
                    preferRelative: true
                })));
        },
        get sass() {
            return (sassResolve ||
                (sassResolve = config.createResolver({
                    extensions: ['.scss', '.sass', '.css'],
                    mainFields: ['sass', 'style'],
                    tryIndex: true,
                    tryPrefix: '_',
                    preferRelative: true
                })));
        },
        get less() {
            return (lessResolve ||
                (lessResolve = config.createResolver({
                    extensions: ['.less', '.css'],
                    mainFields: ['less', 'style'],
                    tryIndex: false,
                    preferRelative: true
                })));
        }
    };
}
function getCssResolversKeys(resolvers) {
    return Object.keys(resolvers);
}
async function compileCSS(id, code, config, urlReplacer, atImportResolvers, server) {
    var _a;
    const { modules: modulesOptions, preprocessorOptions } = config.css || {};
    const isModule = modulesOptions !== false && cssModuleRE.test(id);
    // although at serve time it can work without processing, we do need to
    // crawl them in order to register watch dependencies.
    const needInlineImport = code.includes('@import');
    const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code);
    const postcssConfig = await resolvePostcssConfig(config);
    const lang = (_a = id.match(cssLangRE)) === null || _a === void 0 ? void 0 : _a[1];
    // 1. plain css that needs no processing
    if (lang === 'css' &&
        !postcssConfig &&
        !isModule &&
        !needInlineImport &&
        !hasUrl) {
        return { code };
    }
    let map;
    let modules;
    const deps = new Set();
    // 2. pre-processors: sass etc.
    if (isPreProcessor(lang)) {
        const preProcessor = preProcessors[lang];
        let opts = (preprocessorOptions && preprocessorOptions[lang]) || {};
        // support @import from node dependencies by default
        switch (lang) {
            case "scss" /* scss */:
            case "sass" /* sass */:
                opts = {
                    includePaths: ['node_modules'],
                    alias: config.resolve.alias,
                    ...opts
                };
                break;
            case "less" /* less */:
            case "styl" /* styl */:
            case "stylus" /* stylus */:
                opts = {
                    paths: ['node_modules'],
                    alias: config.resolve.alias,
                    ...opts
                };
        }
        // important: set this for relative import resolving
        opts.filename = cleanUrl(id);
        const preprocessResult = await preProcessor(code, config.root, opts, atImportResolvers);
        if (preprocessResult.errors.length) {
            throw preprocessResult.errors[0];
        }
        code = preprocessResult.code;
        map = preprocessResult.map;
        if (preprocessResult.deps) {
            preprocessResult.deps.forEach((dep) => {
                // sometimes sass registers the file itself as a dep
                if (normalizePath(dep) !== normalizePath(opts.filename)) {
                    deps.add(dep);
                }
            });
        }
    }
    // 3. postcss
    const postcssOptions = (postcssConfig && postcssConfig.options) || {};
    const postcssPlugins = postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : [];
    if (needInlineImport) {
        postcssPlugins.unshift((await import('postcss-import')).default({
            async resolve(id, basedir) {
                const resolved = await atImportResolvers.css(id, path.join(basedir, '*'));
                if (resolved) {
                    return path.resolve(resolved);
                }
                return id;
            }
        }));
    }
    postcssPlugins.push(UrlRewritePostcssPlugin({
        replacer: urlReplacer
    }));
    if (isModule) {
        postcssPlugins.unshift((await import('postcss-modules')).default({
            ...modulesOptions,
            getJSON(cssFileName, _modules, outputFileName) {
                modules = _modules;
                if (modulesOptions && typeof modulesOptions.getJSON === 'function') {
                    modulesOptions.getJSON(cssFileName, _modules, outputFileName);
                }
            },
            async resolve(id) {
                for (const key of getCssResolversKeys(atImportResolvers)) {
                    const resolved = await atImportResolvers[key](id);
                    if (resolved) {
                        return path.resolve(resolved);
                    }
                }
                return id;
            }
        }));
    }
    if (!postcssPlugins.length) {
        return {
            code,
            map
        };
    }
    // postcss is an unbundled dep and should be lazy imported
    const postcssResult = await (await import('postcss'))
        .default(postcssPlugins)
        .process(code, {
        ...postcssOptions,
        to: id,
        from: id,
        map: {
            inline: false,
            annotation: false,
            prev: map
        }
    });
    // record CSS dependencies from @imports
    for (const message of postcssResult.messages) {
        if (message.type === 'dependency') {
            deps.add(message.file);
        }
        else if (message.type === 'dir-dependency') {
            // https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#3-dependencies
            const { dir, glob: globPattern = '**' } = message;
            const pattern = normalizePath(path.resolve(path.dirname(id), dir)) + `/` + globPattern;
            const files = glob.sync(pattern, {
                ignore: ['**/node_modules/**']
            });
            for (let i = 0; i < files.length; i++) {
                deps.add(files[i]);
            }
            if (server) {
                // register glob importers so we can trigger updates on file add/remove
                if (!(id in server._globImporters)) {
                    server._globImporters[id] = {
                        module: server.moduleGraph.getModuleById(id),
                        importGlobs: []
                    };
                }
                server._globImporters[id].importGlobs.push({
                    base: config.root,
                    pattern
                });
            }
        }
        else if (message.type === 'warning') {
            let msg = `[vite:css] ${message.text}`;
            if (message.line && message.column) {
                msg += `\n${generateCodeFrame(code, {
                    line: message.line,
                    column: message.column
                })}`;
            }
            config.logger.warn(p.yellow(msg));
        }
    }
    return {
        ast: postcssResult,
        code: postcssResult.css,
        map: postcssResult.map,
        modules,
        deps
    };
}
async function resolvePostcssConfig(config) {
    var _a;
    let result = postcssConfigCache.get(config);
    if (result !== undefined) {
        return result;
    }
    // inline postcss config via vite config
    const inlineOptions = (_a = config.css) === null || _a === void 0 ? void 0 : _a.postcss;
    if (isObject(inlineOptions)) {
        const options = { ...inlineOptions };
        delete options.plugins;
        result = {
            options,
            plugins: inlineOptions.plugins || []
        };
    }
    else {
        try {
            // @ts-ignore
            result = await postcssrc();
        }
        catch (e) {
            if (!/No PostCSS Config found/.test(e.message)) {
                throw e;
            }
            result = null;
        }
    }
    postcssConfigCache.set(config, result);
    return result;
}
// https://drafts.csswg.org/css-syntax-3/#identifier-code-point
// BROWSER VITE patch: no lookbehind for safari support
const cssUrlRE = /(?:^|[^\w\-\u0080-\uffff])url\(\s*('[^']+'|"[^"]+"|[^'")]+)\s*\)/;
const cssImageSetRE = /image-set\(([^)]+)\)/;
const UrlRewritePostcssPlugin = (opts) => {
    if (!opts) {
        throw new Error('base or replace is required');
    }
    return {
        postcssPlugin: 'vite-url-rewrite',
        Once(root) {
            const promises = [];
            root.walkDecls((declaration) => {
                const isCssUrl = cssUrlRE.test(declaration.value);
                const isCssImageSet = cssImageSetRE.test(declaration.value);
                if (isCssUrl || isCssImageSet) {
                    const replacerForDeclaration = (rawUrl) => {
                        var _a;
                        const importer = (_a = declaration.source) === null || _a === void 0 ? void 0 : _a.input.file;
                        return opts.replacer(rawUrl, importer);
                    };
                    const rewriterToUse = isCssUrl ? rewriteCssUrls : rewriteCssImageSet;
                    promises.push(rewriterToUse(declaration.value, replacerForDeclaration).then((url) => {
                        declaration.value = url;
                    }));
                }
            });
            if (promises.length) {
                return Promise.all(promises);
            }
        }
    };
};
UrlRewritePostcssPlugin.postcss = true;
function rewriteCssUrls(css, replacer) {
    return asyncReplace(css, cssUrlRE, async (match) => {
        const [matched, rawUrl] = match;
        return await doUrlReplace(rawUrl, matched, replacer);
    });
}
function rewriteCssImageSet(css, replacer) {
    return asyncReplace(css, cssImageSetRE, async (match) => {
        const [matched, rawUrl] = match;
        const url = await processSrcSet(rawUrl, ({ url }) => doUrlReplace(url, matched, replacer));
        return `image-set(${url})`;
    });
}
async function doUrlReplace(rawUrl, matched, replacer) {
    let wrap = '';
    const first = rawUrl[0];
    if (first === `"` || first === `'`) {
        wrap = first;
        rawUrl = rawUrl.slice(1, -1);
    }
    if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith('#')) {
        return matched;
    }
    return `url(${wrap}${await replacer(rawUrl)}${wrap})`;
}
async function minifyCSS(css, config) {
    const { code, warnings } = await transform(css, {
        loader: 'css',
        minify: true,
        target: config.build.cssTarget || undefined
    });
    if (warnings.length) {
        const msgs = await formatMessages(warnings, { kind: 'warning' });
        config.logger.warn(p.yellow(`warnings when minifying css:\n${msgs.join('\n')}`));
    }
    return code;
}
// #1845
// CSS @import can only appear at top of the file. We need to hoist all @import
// to top when multiple files are concatenated.
async function hoistAtImports(css) {
    const postcss = await import('postcss');
    return (await postcss.default([AtImportHoistPlugin]).process(css)).css;
}
const AtImportHoistPlugin = () => {
    return {
        postcssPlugin: 'vite-hoist-at-imports',
        Once(root) {
            const imports = [];
            root.walkAtRules((rule) => {
                if (rule.name === 'import') {
                    // record in reverse so that can simply prepend to preserve order
                    imports.unshift(rule);
                }
            });
            imports.forEach((i) => root.prepend(i));
        }
    };
};
AtImportHoistPlugin.postcss = true;
const loadedPreprocessors = {};
function loadPreprocessor(lang, root) {
    var _a, _b;
    if (lang in loadedPreprocessors) {
        return loadedPreprocessors[lang];
    }
    try {
        // Search for the preprocessor in the root directory first, and fall back
        // to the default require paths.
        const fallbackPaths = ((_b = (_a = require.resolve).paths) === null || _b === void 0 ? void 0 : _b.call(_a, lang)) || [];
        const resolved = require.resolve(lang, { paths: [root, ...fallbackPaths] });
        return (loadedPreprocessors[lang] = require(resolved));
    }
    catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            throw new Error(`Preprocessor dependency "${lang}" not found. Did you install it?`);
        }
        else {
            const message = new Error(`Preprocessor dependency "${lang}" failed to load:\n${e.message}`);
            message.stack = e.stack + '\n' + message.stack;
            throw message;
        }
    }
}
// .scss/.sass processor
const scss = async (source, root, options, resolvers) => {
    var _a;
    // BROWSER VITE patch: when running in-browser, sass will provide importer as location.origin based url
    const toLocal = (url) => isExternalUrl(url) ? new URL(url).pathname : url;
    // BROWSER VITE patch: dynamic sass import
    const render = (await import('sass').then((m) => m.default || m)).render;
    const internalImporter = (url, importer, done) => {
        importer = toLocal(importer);
        resolvers.sass(url, importer).then((resolved) => {
            if (resolved) {
                // BROWSER VITE patch: fix https://github.com/vitejs/vite/issues/5337
                const file = path.resolve(resolved);
                done === null || done === void 0 ? void 0 : done({ file, contents: fs.readFileSync(file, 'utf-8') });
            }
            else {
                done === null || done === void 0 ? void 0 : done(null);
            }
        });
    };
    const importer = [internalImporter];
    if (options.importer) {
        Array.isArray(options.importer)
            ? importer.push(...options.importer)
            : importer.push(options.importer);
    }
    const finalOptions = {
        ...options,
        data: await getSource(source, options.filename, options.additionalData),
        file: options.filename,
        outFile: options.filename,
        importer
    };
    try {
        const result = await new Promise((resolve, reject) => {
            render(finalOptions, (err, res) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
        const deps = (_a = result.stats.includedFiles) === null || _a === void 0 ? void 0 : _a.map((file) => toLocal(file));
        return {
            code: result.css.toString(),
            errors: [],
            deps
        };
    }
    catch (e) {
        // normalize SASS error
        e.id = e.file;
        e.frame = e.formatted;
        return { code: '', errors: [e], deps: [] };
    }
};
const sass = (source, root, options, aliasResolver) => scss(source, root, {
    ...options,
    indentedSyntax: true
}, aliasResolver);
/**
 * relative url() inside \@imported sass and less files must be rebased to use
 * root file as base.
 */
async function rebaseUrls(file, rootFile, alias) {
    file = path.resolve(file); // ensure os-specific flashes
    // in the same dir, no need to rebase
    const fileDir = path.dirname(file);
    const rootDir = path.dirname(rootFile);
    // no url()
    const content = fs.readFileSync(file, 'utf-8');
    // BROWSER VITE patch: always return content (browser sass has no FS access)
    if (fileDir === rootDir || !cssUrlRE.test(content)) {
        return { file, contents: content };
    }
    const rebased = await rewriteCssUrls(content, (url) => {
        if (url.startsWith('/'))
            return url;
        // match alias, no need to rewrite
        for (const { find } of alias) {
            const matches = typeof find === 'string' ? url.startsWith(find) : find.test(url);
            if (matches) {
                return url;
            }
        }
        const absolute = path.resolve(fileDir, url);
        const relative = path.relative(rootDir, absolute);
        return normalizePath(relative);
    });
    return {
        file,
        contents: rebased
    };
}
// .less
const less = async (source, root, options, resolvers) => {
    const nodeLess = loadPreprocessor("less" /* less */, root);
    const viteResolverPlugin = createViteLessPlugin(nodeLess, options.filename, options.alias, resolvers);
    source = await getSource(source, options.filename, options.additionalData);
    let result;
    try {
        result = await nodeLess.render(source, {
            ...options,
            plugins: [viteResolverPlugin, ...(options.plugins || [])]
        });
    }
    catch (e) {
        const error = e;
        // normalize error info
        const normalizedError = new Error(error.message || error.type);
        normalizedError.loc = {
            file: error.filename || options.filename,
            line: error.line,
            column: error.column
        };
        return { code: '', errors: [normalizedError], deps: [] };
    }
    return {
        code: result.css.toString(),
        deps: result.imports,
        errors: []
    };
};
/**
 * Less manager, lazy initialized
 */
let ViteLessManager;
function createViteLessPlugin(less, rootFile, alias, resolvers) {
    if (!ViteLessManager) {
        ViteLessManager = class ViteManager extends less.FileManager {
            constructor(rootFile, resolvers, alias) {
                super();
                this.rootFile = rootFile;
                this.resolvers = resolvers;
                this.alias = alias;
            }
            supports() {
                return true;
            }
            supportsSync() {
                return false;
            }
            async loadFile(filename, dir, opts, env) {
                const resolved = await this.resolvers.less(filename, path.join(dir, '*'));
                if (resolved) {
                    const result = await rebaseUrls(resolved, this.rootFile, this.alias);
                    let contents;
                    if (result && 'contents' in result) {
                        contents = result.contents;
                    }
                    else {
                        contents = fs.readFileSync(resolved, 'utf-8');
                    }
                    return {
                        filename: path.resolve(resolved),
                        contents
                    };
                }
                else {
                    return super.loadFile(filename, dir, opts, env);
                }
            }
        };
    }
    return {
        install(_, pluginManager) {
            pluginManager.addFileManager(new ViteLessManager(rootFile, resolvers, alias));
        },
        minVersion: [3, 0, 0]
    };
}
// .styl
const styl = async (source, root, options) => {
    var _a;
    const nodeStylus = loadPreprocessor("stylus" /* stylus */, root);
    // Get source with preprocessor options.additionalData. Make sure a new line separator
    // is added to avoid any render error, as added stylus content may not have semi-colon separators
    source = await getSource(source, options.filename, options.additionalData, '\n');
    // Get preprocessor options.imports dependencies as stylus
    // does not return them with its builtin `.deps()` method
    const importsDeps = ((_a = options.imports) !== null && _a !== void 0 ? _a : []).map((dep) => path.resolve(dep));
    try {
        const ref = nodeStylus(source, options);
        // if (map) ref.set('sourcemap', { inline: false, comment: false })
        const result = ref.render();
        // Concat imports deps with computed deps
        const deps = [...ref.deps(), ...importsDeps];
        return { code: result, errors: [], deps };
    }
    catch (e) {
        return { code: '', errors: [e], deps: [] };
    }
};
function getSource(source, filename, additionalData, sep = '') {
    if (!additionalData)
        return source;
    if (typeof additionalData === 'function') {
        return additionalData(source, filename);
    }
    return additionalData + sep + source;
}
const preProcessors = Object.freeze({
    ["less" /* less */]: less,
    ["sass" /* sass */]: sass,
    ["scss" /* scss */]: scss,
    ["styl" /* styl */]: styl,
    ["stylus" /* stylus */]: styl
});
function isPreProcessor(lang) {
    return lang && lang in preProcessors;
}

async function transformImportGlob(source, pos, importer, importIndex, root, normalizeUrl, preload = true) {
    const isEager = source.slice(pos, pos + 21) === 'import.meta.globEager';
    const isEagerDefault = isEager && source.slice(pos + 21, pos + 28) === 'Default';
    const err = (msg) => {
        const e = new Error(`Invalid glob import syntax: ${msg}`);
        e.pos = pos;
        return e;
    };
    importer = cleanUrl(importer);
    const importerBasename = path.basename(importer);
    let [pattern, endIndex] = lexGlobPattern(source, pos);
    if (!pattern.startsWith('.') && !pattern.startsWith('/')) {
        throw err(`pattern must start with "." or "/" (relative to project root)`);
    }
    let base;
    let parentDepth = 0;
    const isAbsolute = pattern.startsWith('/');
    if (isAbsolute) {
        base = path.resolve(root);
        pattern = pattern.slice(1);
    }
    else {
        base = path.dirname(importer);
        while (pattern.startsWith('../')) {
            pattern = pattern.slice(3);
            base = path.resolve(base, '../');
            parentDepth++;
        }
        if (pattern.startsWith('./')) {
            pattern = pattern.slice(2);
        }
    }
    const files = glob.sync(pattern, {
        cwd: base,
        ignore: ['**/node_modules/**']
    });
    const imports = [];
    let importsString = ``;
    let entries = ``;
    for (let i = 0; i < files.length; i++) {
        // skip importer itself
        if (files[i] === importerBasename)
            continue;
        const file = isAbsolute
            ? `/${files[i]}`
            : parentDepth
                ? `${'../'.repeat(parentDepth)}${files[i]}`
                : `./${files[i]}`;
        let importee = file;
        if (normalizeUrl) {
            [importee] = await normalizeUrl(file, pos);
        }
        imports.push(importee);
        const identifier = `__glob_${importIndex}_${i}`;
        if (isEager) {
            importsString += `import ${isEagerDefault ? `` : `* as `}${identifier} from ${JSON.stringify(importee)};`;
            entries += ` ${JSON.stringify(file)}: ${identifier},`;
        }
        else {
            let imp = `import(${JSON.stringify(importee)})`;
            if (!normalizeUrl && preload) {
                imp =
                    `(${isModernFlag}` +
                        `? ${preloadMethod}(()=>${imp},"${preloadMarker}")` +
                        `: ${imp})`;
            }
            entries += ` ${JSON.stringify(file)}: () => ${imp},`;
        }
    }
    return {
        imports,
        importsString,
        exp: `{${entries}}`,
        endIndex,
        isEager,
        pattern,
        base
    };
}
function lexGlobPattern(code, pos) {
    let state = 0 /* inCall */;
    let pattern = '';
    let i = code.indexOf(`(`, pos) + 1;
    outer: for (; i < code.length; i++) {
        const char = code.charAt(i);
        switch (state) {
            case 0 /* inCall */:
                if (char === `'`) {
                    state = 1 /* inSingleQuoteString */;
                }
                else if (char === `"`) {
                    state = 2 /* inDoubleQuoteString */;
                }
                else if (char === '`') {
                    state = 3 /* inTemplateString */;
                }
                else if (/\s/.test(char)) {
                    continue;
                }
                else {
                    error$1(i);
                }
                break;
            case 1 /* inSingleQuoteString */:
                if (char === `'`) {
                    break outer;
                }
                else {
                    pattern += char;
                }
                break;
            case 2 /* inDoubleQuoteString */:
                if (char === `"`) {
                    break outer;
                }
                else {
                    pattern += char;
                }
                break;
            case 3 /* inTemplateString */:
                if (char === '`') {
                    break outer;
                }
                else {
                    pattern += char;
                }
                break;
            default:
                throw new Error('unknown import.meta.glob lexer state');
        }
    }
    return [pattern, code.indexOf(`)`, i) + 1];
}
function error$1(pos) {
    const err = new Error(`import.meta.glob() can only accept string literals.`);
    err.pos = pos;
    throw err;
}

/**
 * A flag for injected helpers. This flag will be set to `false` if the output
 * target is not native es - so that injected helper logic can be conditionally
 * dropped.
 */
const isModernFlag = `__VITE_IS_MODERN__`;
const preloadMethod = `__vitePreload`;
const preloadMarker = `__VITE_PRELOAD__`;

const htmlProxyRE = /\?html-proxy&index=(\d+)\.js$/;
// HTML Proxy Caches are stored by config -> filePath -> index
const htmlProxyMap = new WeakMap();
function htmlInlineScriptProxyPlugin(config) {
    return {
        name: 'vite:html-inline-script-proxy',
        resolveId(id) {
            if (htmlProxyRE.test(id)) {
                return id;
            }
        },
        buildStart() {
            htmlProxyMap.set(config, new Map());
        },
        load(id) {
            const proxyMatch = id.match(htmlProxyRE);
            if (proxyMatch) {
                const index = Number(proxyMatch[1]);
                const file = cleanUrl(id);
                const url = file.replace(normalizePath(config.root), '');
                const result = htmlProxyMap.get(config).get(url)[index];
                if (result) {
                    return result;
                }
                else {
                    throw new Error(`No matching HTML proxy module found from ${id}`);
                }
            }
        }
    };
}
/** Add script to cache */
function addToHTMLProxyCache(config, filePath, index, code) {
    if (!htmlProxyMap.get(config)) {
        htmlProxyMap.set(config, new Map());
    }
    if (!htmlProxyMap.get(config).get(filePath)) {
        htmlProxyMap.get(config).set(filePath, []);
    }
    htmlProxyMap.get(config).get(filePath)[index] = code;
}
// this extends the config in @vue/compiler-sfc with <link href>
const assetAttrsConfig = {
    link: ['href'],
    video: ['src', 'poster'],
    source: ['src', 'srcset'],
    img: ['src', 'srcset'],
    image: ['xlink:href', 'href'],
    use: ['xlink:href', 'href']
};
async function traverseHtml(html, filePath, visitor) {
    // lazy load compiler
    const { parse, transform } = await import('@vue/compiler-dom');
    // @vue/compiler-core doesn't like lowercase doctypes
    html = html.replace(/<!doctype\s/i, '<!DOCTYPE ');
    try {
        const ast = parse(html, { comments: true });
        transform(ast, {
            nodeTransforms: [visitor]
        });
    }
    catch (e) {
        const parseError = {
            loc: filePath,
            frame: '',
            ...formatParseError(e, filePath, html)
        };
        throw new Error(`Unable to parse ${JSON.stringify(parseError.loc)}\n${parseError.frame}`);
    }
}
function getScriptInfo(node) {
    let src;
    let isModule = false;
    let isAsync = false;
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (p.name === 'src') {
                src = p;
            }
            else if (p.name === 'type' && p.value && p.value.content === 'module') {
                isModule = true;
            }
            else if (p.name === 'async') {
                isAsync = true;
            }
        }
    }
    return { src, isModule, isAsync };
}
function formatParseError(e, id, html) {
    // normalize the error to rollup format
    if (e.loc) {
        e.frame = generateCodeFrame(html, e.loc.start.offset);
        e.loc = {
            file: id,
            line: e.loc.start.line,
            column: e.loc.start.column
        };
    }
    return e;
}
function resolveHtmlTransforms(plugins) {
    const preHooks = [];
    const postHooks = [];
    for (const plugin of plugins) {
        const hook = plugin.transformIndexHtml;
        if (hook) {
            if (typeof hook === 'function') {
                postHooks.push(hook);
            }
            else if (hook.enforce === 'pre') {
                preHooks.push(hook.transform);
            }
            else {
                postHooks.push(hook.transform);
            }
        }
    }
    return [preHooks, postHooks];
}
async function applyHtmlTransforms(html, hooks, ctx) {
    const headTags = [];
    const headPrependTags = [];
    const bodyTags = [];
    const bodyPrependTags = [];
    for (const hook of hooks) {
        const res = await hook(html, ctx);
        if (!res) {
            continue;
        }
        if (typeof res === 'string') {
            html = res;
        }
        else {
            let tags;
            if (Array.isArray(res)) {
                tags = res;
            }
            else {
                html = res.html || html;
                tags = res.tags;
            }
            for (const tag of tags) {
                if (tag.injectTo === 'body') {
                    bodyTags.push(tag);
                }
                else if (tag.injectTo === 'body-prepend') {
                    bodyPrependTags.push(tag);
                }
                else if (tag.injectTo === 'head') {
                    headTags.push(tag);
                }
                else {
                    headPrependTags.push(tag);
                }
            }
        }
    }
    // inject tags
    if (headPrependTags.length) {
        html = injectToHead(html, headPrependTags, true);
    }
    if (headTags.length) {
        html = injectToHead(html, headTags);
    }
    if (bodyPrependTags.length) {
        html = injectToBody(html, bodyPrependTags, true);
    }
    if (bodyTags.length) {
        html = injectToBody(html, bodyTags);
    }
    return html;
}
const headInjectRE = /([ \t]*)<\/head>/i;
const headPrependInjectRE = /([ \t]*)<head[^>]*>/i;
const htmlInjectRE = /<\/html>/i;
const htmlPrependInjectRE = /([ \t]*)<html[^>]*>/i;
const bodyInjectRE = /([ \t]*)<\/body>/i;
const bodyPrependInjectRE = /([ \t]*)<body[^>]*>/i;
const doctypePrependInjectRE = /<!doctype html>/i;
function injectToHead(html, tags, prepend = false) {
    if (prepend) {
        // inject as the first element of head
        if (headPrependInjectRE.test(html)) {
            return html.replace(headPrependInjectRE, (match, p1) => `${match}\n${serializeTags(tags, incrementIndent(p1))}`);
        }
    }
    else {
        // inject before head close
        if (headInjectRE.test(html)) {
            // respect indentation of head tag
            return html.replace(headInjectRE, (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`);
        }
        // try to inject before the body tag
        if (bodyPrependInjectRE.test(html)) {
            return html.replace(bodyPrependInjectRE, (match, p1) => `${serializeTags(tags, p1)}\n${match}`);
        }
    }
    // if no head tag is present, we prepend the tag for both prepend and append
    return prependInjectFallback(html, tags);
}
function injectToBody(html, tags, prepend = false) {
    if (prepend) {
        // inject after body open
        if (bodyPrependInjectRE.test(html)) {
            return html.replace(bodyPrependInjectRE, (match, p1) => `${match}\n${serializeTags(tags, incrementIndent(p1))}`);
        }
        // if no there is no body tag, inject after head or fallback to prepend in html
        if (headInjectRE.test(html)) {
            return html.replace(headInjectRE, (match, p1) => `${match}\n${serializeTags(tags, p1)}`);
        }
        return prependInjectFallback(html, tags);
    }
    else {
        // inject before body close
        if (bodyInjectRE.test(html)) {
            return html.replace(bodyInjectRE, (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`);
        }
        // if no body tag is present, append to the html tag, or at the end of the file
        if (htmlInjectRE.test(html)) {
            return html.replace(htmlInjectRE, `${serializeTags(tags)}\n$&`);
        }
        return html + `\n` + serializeTags(tags);
    }
}
function prependInjectFallback(html, tags) {
    // prepend to the html tag, append after doctype, or the document start
    if (htmlPrependInjectRE.test(html)) {
        return html.replace(htmlPrependInjectRE, `$&\n${serializeTags(tags)}`);
    }
    if (doctypePrependInjectRE.test(html)) {
        return html.replace(doctypePrependInjectRE, `$&\n${serializeTags(tags)}`);
    }
    return serializeTags(tags) + html;
}
const unaryTags = new Set(['link', 'meta', 'base']);
function serializeTag({ tag, attrs, children }, indent = '') {
    if (unaryTags.has(tag)) {
        return `<${tag}${serializeAttrs(attrs)}>`;
    }
    else {
        return `<${tag}${serializeAttrs(attrs)}>${serializeTags(children, incrementIndent(indent))}</${tag}>`;
    }
}
function serializeTags(tags, indent = '') {
    if (typeof tags === 'string') {
        return tags;
    }
    else if (tags && tags.length) {
        return tags.map((tag) => `${indent}${serializeTag(tag, indent)}\n`).join('');
    }
    return '';
}
function serializeAttrs(attrs) {
    let res = '';
    for (const key in attrs) {
        if (typeof attrs[key] === 'boolean') {
            res += attrs[key] ? ` ${key}` : ``;
        }
        else {
            res += ` ${key}=${JSON.stringify(attrs[key])}`;
        }
    }
    return res;
}
function incrementIndent(indent = '') {
    return `${indent}${indent[0] === '\t' ? '\t' : '  '}`;
}

const debug$2 = createDebugger('vite:esbuild');
let server;
async function transformWithEsbuild(code, filename, options, inMap) {
    var _a, _b, _c;
    let loader = options === null || options === void 0 ? void 0 : options.loader;
    if (!loader) {
        // if the id ends with a valid ext, use it (e.g. vue blocks)
        // otherwise, cleanup the query before checking the ext
        const ext = path
            .extname(/\.\w+$/.test(filename) ? filename : cleanUrl(filename))
            .slice(1);
        if (ext === 'cjs' || ext === 'mjs') {
            loader = 'js';
        }
        else {
            loader = ext;
        }
    }
    let tsconfigRaw = options === null || options === void 0 ? void 0 : options.tsconfigRaw;
    // if options provide tsconfigraw in string, it takes highest precedence
    if (typeof tsconfigRaw !== 'string') {
        // these fields would affect the compilation result
        // https://esbuild.github.io/content-types/#tsconfig-json
        const meaningfulFields = [
            'jsxFactory',
            'jsxFragmentFactory',
            'useDefineForClassFields',
            'importsNotUsedAsValues'
        ];
        const compilerOptionsForFile = {};
        if (loader === 'ts' || loader === 'tsx') {
            const loadedTsconfig = await loadTsconfigJsonForFile(filename);
            const loadedCompilerOptions = (_a = loadedTsconfig.compilerOptions) !== null && _a !== void 0 ? _a : {};
            for (const field of meaningfulFields) {
                if (field in loadedCompilerOptions) {
                    // @ts-ignore TypeScript can't tell they are of the same type
                    compilerOptionsForFile[field] = loadedCompilerOptions[field];
                }
            }
            // align with TypeScript 4.3
            // https://github.com/microsoft/TypeScript/pull/42663
            if (((_b = loadedCompilerOptions.target) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'esnext') {
                compilerOptionsForFile.useDefineForClassFields =
                    (_c = loadedCompilerOptions.useDefineForClassFields) !== null && _c !== void 0 ? _c : true;
            }
        }
        tsconfigRaw = {
            ...tsconfigRaw,
            compilerOptions: {
                ...compilerOptionsForFile,
                ...tsconfigRaw === null || tsconfigRaw === void 0 ? void 0 : tsconfigRaw.compilerOptions
            }
        };
    }
    const resolvedOptions = {
        sourcemap: true,
        // ensure source file name contains full query
        sourcefile: filename,
        ...options,
        loader,
        tsconfigRaw
    };
    delete resolvedOptions.include;
    delete resolvedOptions.exclude;
    delete resolvedOptions.jsxInject;
    try {
        const result = await transform(code, resolvedOptions);
        let map;
        if (inMap && resolvedOptions.sourcemap) {
            const nextMap = JSON.parse(result.map);
            nextMap.sourcesContent = [];
            map = combineSourcemaps(filename, [
                nextMap,
                inMap
            ]);
        }
        else {
            map = resolvedOptions.sourcemap
                ? JSON.parse(result.map)
                : { mappings: '' };
        }
        if (Array.isArray(map.sources)) {
            map.sources = map.sources.map((it) => toUpperCaseDriveLetter(it));
        }
        return {
            ...result,
            map
        };
    }
    catch (e) {
        debug$2(`esbuild error with options used: `, resolvedOptions);
        // patch error information
        if (e.errors) {
            e.frame = '';
            e.errors.forEach((m) => {
                e.frame += `\n` + prettifyMessage(m, code);
            });
            e.loc = e.errors[0].location;
        }
        throw e;
    }
}
function esbuildPlugin(options = {}) {
    const filter = createFilter(options.include || /\.(tsx?|jsx)$/, options.exclude || /\.js$/);
    return {
        name: 'vite:esbuild',
        configureServer(_server) {
            server = _server;
            server.watcher
                .on('add', reloadOnTsconfigChange)
                .on('change', reloadOnTsconfigChange)
                .on('unlink', reloadOnTsconfigChange);
        },
        async transform(code, id) {
            if (filter(id) || filter(cleanUrl(id))) {
                const result = await transformWithEsbuild(code, id, options);
                if (result.warnings.length) {
                    result.warnings.forEach((m) => {
                        this.warn(prettifyMessage(m, code));
                    });
                }
                if (options.jsxInject && /\.(?:j|t)sx\b/.test(id)) {
                    result.code = options.jsxInject + ';' + result.code;
                }
                return {
                    code: result.code,
                    map: result.map
                };
            }
        }
    };
}
function prettifyMessage(m, code) {
    let res = p.yellow(m.text);
    if (m.location) {
        const lines = code.split(/\r?\n/g);
        const line = Number(m.location.line);
        const column = Number(m.location.column);
        const offset = lines
            .slice(0, line - 1)
            .map((l) => l.length)
            .reduce((total, l) => total + l + 1, 0) + column;
        res += `\n` + generateCodeFrame(code, offset, offset + 1);
    }
    return res + `\n`;
}
const tsconfigCache = new Map();
async function loadTsconfigJsonForFile(filename) {
    try {
        const result = await parse$1(filename, {
            cache: tsconfigCache,
            resolveWithEmptyIfConfigNotFound: true
        });
        // tsconfig could be out of root, make sure it is watched on dev
        if (server && result.tsconfigFile !== 'no_tsconfig_file_found') {
            ensureWatchedFile(server.watcher, result.tsconfigFile, server.config.root);
        }
        return result.tsconfig;
    }
    catch (e) {
        if (e instanceof TSConfckParseError) {
            // tsconfig could be out of root, make sure it is watched on dev
            if (server && e.tsconfigFile) {
                ensureWatchedFile(server.watcher, e.tsconfigFile, server.config.root);
            }
        }
        throw e;
    }
}
function reloadOnTsconfigChange(changedFile) {
    // any tsconfig.json that's added in the workspace could be closer to a code file than a previously cached one
    // any json file in the tsconfig cache could have been used to compile ts
    if (path.basename(changedFile) === 'tsconfig.json' ||
        (changedFile.endsWith('.json') && tsconfigCache.has(changedFile))) {
        server.config.logger.info(`changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure typescript is compiled with updated config values.`, { clear: server.config.clearScreen, timestamp: true });
        // clear tsconfig cache so that recompile works with up2date configs
        tsconfigCache.clear();
        // clear module graph to remove code compiled with outdated config
        server.moduleGraph.invalidateAll();
        // force full reload
        server.ws.send({
            type: 'full-reload',
            path: '*'
        });
    }
}

function resolvePackageData(id, basedir, preserveSymlinks = false, packageCache) {
    let pkg;
    let cacheKey;
    if (packageCache) {
        cacheKey = `${id}&${basedir}&${preserveSymlinks}`;
        if ((pkg = packageCache.get(cacheKey))) {
            return pkg;
        }
    }
    let pkgPath;
    try {
        pkgPath = resolveFrom(`${id}/package.json`, basedir, preserveSymlinks);
        pkg = loadPackageData(pkgPath, true, packageCache);
        if (packageCache) {
            packageCache.set(cacheKey, pkg);
        }
        return pkg;
    }
    catch (e) {
        if (e instanceof SyntaxError) ;
        // Ignore error for missing package.json
        else if (e.code !== 'MODULE_NOT_FOUND') {
            throw e;
        }
    }
    return null;
}
function loadPackageData(pkgPath, preserveSymlinks, packageCache) {
    if (!preserveSymlinks) {
        pkgPath = fs.realpathSync.native(pkgPath);
    }
    let cached;
    if ((cached = packageCache === null || packageCache === void 0 ? void 0 : packageCache.get(pkgPath))) {
        return cached;
    }
    const data = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
    const pkgDir = path.dirname(pkgPath);
    const { sideEffects } = data;
    let hasSideEffects;
    if (typeof sideEffects === 'boolean') {
        hasSideEffects = () => sideEffects;
    }
    else if (Array.isArray(sideEffects)) {
        hasSideEffects = createFilter(sideEffects, null, { resolve: pkgDir });
    }
    else {
        hasSideEffects = () => true;
    }
    const pkg = {
        dir: pkgDir,
        data,
        hasSideEffects,
        webResolvedImports: {},
        nodeResolvedImports: {},
        setResolvedCache(key, entry, targetWeb) {
            if (targetWeb) {
                pkg.webResolvedImports[key] = entry;
            }
            else {
                pkg.nodeResolvedImports[key] = entry;
            }
        },
        getResolvedCache(key, targetWeb) {
            if (targetWeb) {
                return pkg.webResolvedImports[key];
            }
            else {
                return pkg.nodeResolvedImports[key];
            }
        }
    };
    packageCache === null || packageCache === void 0 ? void 0 : packageCache.set(pkgPath, pkg);
    return pkg;
}

// special id for paths marked with browser: false
// https://github.com/defunctzombie/package-browser-field-spec#ignore-a-module
const browserExternalId = '__vite-browser-external';
function tryFsResolve$1(fsPath, options, tryIndex = true, targetWeb = true) {
    let file = fsPath;
    let postfix = '';
    let postfixIndex = fsPath.indexOf('?');
    if (postfixIndex < 0) {
        postfixIndex = fsPath.indexOf('#');
    }
    if (postfixIndex > 0) {
        file = fsPath.slice(0, postfixIndex);
        postfix = fsPath.slice(postfixIndex);
    }
    let res;
    // if we fould postfix exist, we should first try resolving file with postfix. details see #4703.
    if (postfix &&
        (res = tryResolveFile$1(fsPath, '', options, false, targetWeb, options.tryPrefix, options.skipPackageJson))) {
        return res;
    }
    if ((res = tryResolveFile$1(file, postfix, options, false, targetWeb, options.tryPrefix, options.skipPackageJson))) {
        return res;
    }
    for (const ext of options.extensions || DEFAULT_EXTENSIONS) {
        if (postfix &&
            (res = tryResolveFile$1(fsPath + ext, '', options, false, targetWeb, options.tryPrefix, options.skipPackageJson))) {
            return res;
        }
        if ((res = tryResolveFile$1(file + ext, postfix, options, false, targetWeb, options.tryPrefix, options.skipPackageJson))) {
            return res;
        }
    }
    if (postfix &&
        (res = tryResolveFile$1(fsPath, '', options, tryIndex, targetWeb, options.tryPrefix, options.skipPackageJson))) {
        return res;
    }
    if ((res = tryResolveFile$1(file, postfix, options, tryIndex, targetWeb, options.tryPrefix, options.skipPackageJson))) {
        return res;
    }
}
function tryResolveFile$1(file, postfix, options, tryIndex, targetWeb, tryPrefix, skipPackageJson) {
    // #2051 if we don't have read permission on a directory, existsSync() still
    // works and will result in massively slow subsequent checks (which are
    // unnecessary in the first place)
    if (isFileReadable(file)) {
        if (!fs.statSync(file).isDirectory()) {
            return getRealPath(file, options.preserveSymlinks) + postfix;
        }
        else if (tryIndex) {
            if (!skipPackageJson) {
                const pkgPath = file + '/package.json';
                try {
                    // path points to a node package
                    const pkg = loadPackageData(pkgPath, options.preserveSymlinks);
                    const resolved = resolvePackageEntry(file, pkg, targetWeb, options);
                    return resolved;
                }
                catch (e) {
                    if (e.code !== 'ENOENT') {
                        throw e;
                    }
                }
            }
            const index = tryFsResolve$1(file + '/index', options);
            if (index)
                return index + postfix;
        }
    }
    const tryTsExtension = options.isFromTsImporter && isPossibleTsOutput(file);
    if (tryTsExtension) {
        const tsSrcPath = getTsSrcPath(file);
        return tryResolveFile$1(tsSrcPath, postfix, options, tryIndex, targetWeb, tryPrefix, skipPackageJson);
    }
    if (tryPrefix) {
        const prefixed = `${path.dirname(file)}/${tryPrefix}${path.basename(file)}`;
        return tryResolveFile$1(prefixed, postfix, options, tryIndex, targetWeb);
    }
}
const idToPkgMap = new Map();
function tryNodeResolve(id, importer, options, targetWeb, server, ssr) {
    var _a, _b, _c;
    const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options;
    // split id by last '>' for nested selected packages, for example:
    // 'foo > bar > baz' => 'foo > bar' & 'baz'
    // 'foo'             => ''          & 'foo'
    const lastArrowIndex = id.lastIndexOf('>');
    const nestedRoot = id.substring(0, lastArrowIndex).trim();
    const nestedPath = id.substring(lastArrowIndex + 1).trim();
    const possiblePkgIds = [];
    for (let prevSlashIndex = -1;;) {
        let slashIndex = nestedPath.indexOf('/', prevSlashIndex + 1);
        if (slashIndex < 0) {
            slashIndex = nestedPath.length;
        }
        const part = nestedPath.slice(prevSlashIndex + 1, (prevSlashIndex = slashIndex));
        if (!part) {
            break;
        }
        // Assume path parts with an extension are not package roots, except for the
        // first path part (since periods are sadly allowed in package names).
        // At the same time, skip the first path part if it begins with "@"
        // (since "@foo/bar" should be treated as the top-level path).
        if (possiblePkgIds.length ? path.extname(part) : part[0] === '@') {
            continue;
        }
        const possiblePkgId = nestedPath.slice(0, slashIndex);
        possiblePkgIds.push(possiblePkgId);
    }
    let basedir;
    if (dedupe === null || dedupe === void 0 ? void 0 : dedupe.some((id) => possiblePkgIds.includes(id))) {
        basedir = root;
    }
    else if (importer &&
        path.isAbsolute(importer) &&
        fs.existsSync(cleanUrl(importer))) {
        basedir = path.dirname(importer);
    }
    else {
        basedir = root;
    }
    // nested node module, step-by-step resolve to the basedir of the nestedPath
    if (nestedRoot) {
        basedir = nestedResolveFrom(nestedRoot, basedir, preserveSymlinks);
    }
    let pkg;
    const pkgId = possiblePkgIds.reverse().find((pkgId) => {
        pkg = resolvePackageData(pkgId, basedir, preserveSymlinks, packageCache);
        return pkg;
    });
    if (!pkg) {
        return;
    }
    let resolveId = resolvePackageEntry;
    let unresolvedId = pkgId;
    if (unresolvedId !== nestedPath) {
        resolveId = resolveDeepImport;
        unresolvedId = '.' + nestedPath.slice(pkgId.length);
    }
    let resolved;
    try {
        resolved = resolveId(unresolvedId, pkg, targetWeb, options);
    }
    catch (err) {
        if (!options.tryEsmOnly) {
            throw err;
        }
    }
    if (!resolved && options.tryEsmOnly) {
        resolved = resolveId(unresolvedId, pkg, targetWeb, {
            ...options,
            isRequire: false,
            mainFields: DEFAULT_MAIN_FIELDS,
            extensions: DEFAULT_EXTENSIONS
        });
    }
    if (!resolved) {
        return;
    }
    // link id to pkg for browser field mapping check
    idToPkgMap.set(resolved, pkg);
    if (isBuild) {
        // Resolve package side effects for build so that rollup can better
        // perform tree-shaking
        return {
            id: resolved,
            moduleSideEffects: pkg.hasSideEffects(resolved)
        };
    }
    else {
        if (!resolved.includes('node_modules') || // linked
            !server || // build
            server._isRunningOptimizer || // optimizing
            !server._optimizeDepsMetadata) {
            return { id: resolved };
        }
        // if we reach here, it's a valid dep import that hasn't been optimized.
        const isJsType = OPTIMIZABLE_ENTRY_RE.test(resolved);
        const exclude = (_a = server.config.optimizeDeps) === null || _a === void 0 ? void 0 : _a.exclude;
        if (!isJsType ||
            (importer === null || importer === void 0 ? void 0 : importer.includes('node_modules')) ||
            (exclude === null || exclude === void 0 ? void 0 : exclude.includes(pkgId)) ||
            (exclude === null || exclude === void 0 ? void 0 : exclude.includes(nestedPath)) ||
            SPECIAL_QUERY_RE.test(resolved) ||
            ssr) {
            // excluded from optimization
            // Inject a version query to npm deps so that the browser
            // can cache it without re-validation, but only do so for known js types.
            // otherwise we may introduce duplicated modules for externalized files
            // from pre-bundled deps.
            const versionHash = (_b = server._optimizeDepsMetadata) === null || _b === void 0 ? void 0 : _b.browserHash;
            if (versionHash && isJsType) {
                resolved = injectQuery(resolved, `v=${versionHash}`);
            }
        }
        else {
            // this is a missing import.
            // queue optimize-deps re-run.
            (_c = server._registerMissingImport) === null || _c === void 0 ? void 0 : _c.call(server, id, resolved, ssr);
        }
        return { id: resolved };
    }
}
function resolvePackageEntry(id, { dir, data, setResolvedCache, getResolvedCache }, targetWeb, options) {
    var _a, _b;
    const cached = getResolvedCache('.', targetWeb);
    if (cached) {
        return cached;
    }
    try {
        let entryPoint;
        // resolve exports field with highest priority
        // using https://github.com/lukeed/resolve.exports
        if (data.exports) {
            entryPoint = resolveExports(data, '.', options, targetWeb);
        }
        // if exports resolved to .mjs, still resolve other fields.
        // This is because .mjs files can technically import .cjs files which would
        // make them invalid for pure ESM environments - so if other module/browser
        // fields are present, prioritize those instead.
        if (targetWeb && (!entryPoint || entryPoint.endsWith('.mjs'))) {
            // check browser field
            // https://github.com/defunctzombie/package-browser-field-spec
            const browserEntry = typeof data.browser === 'string'
                ? data.browser
                : isObject(data.browser) && data.browser['.'];
            if (browserEntry) {
                // check if the package also has a "module" field.
                if (typeof data.module === 'string' && data.module !== browserEntry) {
                    // if both are present, we may have a problem: some package points both
                    // to ESM, with "module" targeting Node.js, while some packages points
                    // "module" to browser ESM and "browser" to UMD.
                    // the heuristics here is to actually read the browser entry when
                    // possible and check for hints of UMD. If it is UMD, prefer "module"
                    // instead; Otherwise, assume it's ESM and use it.
                    const resolvedBrowserEntry = tryFsResolve$1(path.join(dir, browserEntry), options);
                    if (resolvedBrowserEntry) {
                        const content = fs.readFileSync(resolvedBrowserEntry, 'utf-8');
                        if ((/typeof exports\s*==/.test(content) &&
                            /typeof module\s*==/.test(content)) ||
                            /module\.exports\s*=/.test(content)) {
                            // likely UMD or CJS(!!! e.g. firebase 7.x), prefer module
                            entryPoint = data.module;
                        }
                    }
                }
                else {
                    entryPoint = browserEntry;
                }
            }
        }
        if (!entryPoint || entryPoint.endsWith('.mjs')) {
            for (const field of options.mainFields || DEFAULT_MAIN_FIELDS) {
                if (typeof data[field] === 'string') {
                    entryPoint = data[field];
                    break;
                }
            }
        }
        entryPoint = entryPoint || data.main || 'index.js';
        // make sure we don't get scripts when looking for sass
        if (((_a = options.mainFields) === null || _a === void 0 ? void 0 : _a[0]) === 'sass' &&
            !((_b = options.extensions) === null || _b === void 0 ? void 0 : _b.includes(path.extname(entryPoint)))) {
            entryPoint = '';
            options.skipPackageJson = true;
        }
        // resolve object browser field in package.json
        const { browser: browserField } = data;
        if (targetWeb && isObject(browserField)) {
            entryPoint = mapWithBrowserField(entryPoint, browserField) || entryPoint;
        }
        entryPoint = path.join(dir, entryPoint);
        const resolvedEntryPoint = tryFsResolve$1(entryPoint, options);
        if (resolvedEntryPoint) {
            setResolvedCache('.', resolvedEntryPoint, targetWeb);
            return resolvedEntryPoint;
        }
        else {
            packageEntryFailure(id);
        }
    }
    catch (e) {
        packageEntryFailure(id, e.message);
    }
}
function packageEntryFailure(id, details) {
    throw new Error(`Failed to resolve entry for package "${id}". ` +
        `The package may have incorrect main/module/exports specified in its package.json` +
        (details ? ': ' + details : '.'));
}
function resolveExports(pkg, key, options, targetWeb) {
    const conditions = [options.isProduction ? 'production' : 'development'];
    if (!options.isRequire) {
        conditions.push('module');
    }
    if (options.conditions) {
        conditions.push(...options.conditions);
    }
    return resolve$1(pkg, key, {
        browser: targetWeb,
        require: options.isRequire,
        conditions
    });
}
function resolveDeepImport(id, { webResolvedImports, setResolvedCache, getResolvedCache, dir, data }, targetWeb, options) {
    const cache = getResolvedCache(id, targetWeb);
    if (cache) {
        return cache;
    }
    let relativeId = id;
    const { exports: exportsField, browser: browserField } = data;
    // map relative based on exports data
    if (exportsField) {
        if (isObject(exportsField) && !Array.isArray(exportsField)) {
            relativeId = resolveExports(data, relativeId, options, targetWeb);
        }
        else {
            // not exposed
            relativeId = undefined;
        }
        if (!relativeId) {
            throw new Error(`Package subpath '${relativeId}' is not defined by "exports" in ` +
                `${path.join(dir, 'package.json')}.`);
        }
    }
    else if (targetWeb && isObject(browserField)) {
        const mapped = mapWithBrowserField(relativeId, browserField);
        if (mapped) {
            relativeId = mapped;
        }
        else if (mapped === false) {
            return (webResolvedImports[id] = browserExternalId);
        }
    }
    if (relativeId) {
        const resolved = tryFsResolve$1(path.join(dir, relativeId), options, !exportsField, // try index only if no exports field
        targetWeb);
        if (resolved) {
            setResolvedCache(id, resolved, targetWeb);
            return resolved;
        }
    }
}
/**
 * given a relative path in pkg dir,
 * return a relative path in pkg dir,
 * mapped with the "map" object
 *
 * - Returning `undefined` means there is no browser mapping for this id
 * - Returning `false` means this id is explicitly externalized for browser
 */
function mapWithBrowserField(relativePathInPkgDir, map) {
    const normalizedPath = path.posix.normalize(relativePathInPkgDir);
    for (const key in map) {
        const normalizedKey = path.posix.normalize(key);
        if (normalizedPath === normalizedKey ||
            equalWithoutSuffix(normalizedPath, normalizedKey, '.js') ||
            equalWithoutSuffix(normalizedPath, normalizedKey, '/index.js')) {
            return map[key];
        }
    }
}
function equalWithoutSuffix(path, key, suffix) {
    return key.endsWith(suffix) && key.slice(0, -suffix.length) === path;
}
function getRealPath(resolved, preserveSymlinks) {
    resolved = ensureVolumeInPath(resolved);
    if (!preserveSymlinks && browserExternalId !== resolved) {
        resolved = fs.realpathSync(resolved);
    }
    return normalizePath(resolved);
}

const debug$1 = createDebugger('vite:ssr-external');
/**
 * Heuristics for determining whether a dependency should be externalized for
 * server-side rendering.
 */
function resolveSSRExternal(config, knownImports) {
    var _a;
    const ssrConfig = config.ssr;
    if ((ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.noExternal) === true) {
        return [];
    }
    const ssrExternals = new Set();
    const seen = new Set();
    (_a = ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.external) === null || _a === void 0 ? void 0 : _a.forEach((id) => {
        ssrExternals.add(id);
        seen.add(id);
    });
    collectExternals(config.root, config.resolve.preserveSymlinks, ssrExternals, seen, config.logger);
    const importedDeps = knownImports.map(getNpmPackageName).filter(isDefined);
    for (const dep of importedDeps) {
        // Assume external if not yet seen
        // At this point, the project root and any linked packages have had their dependencies checked,
        // so we can safely mark any knownImports not yet seen as external. They are guaranteed to be
        // dependencies of packages in node_modules.
        if (!seen.has(dep)) {
            ssrExternals.add(dep);
        }
    }
    // ensure `vite/dynamic-import-polyfill` is bundled (issue #1865)
    ssrExternals.delete('vite');
    let externals = [...ssrExternals];
    if (ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.noExternal) {
        externals = externals.filter(createFilter(undefined, ssrConfig.noExternal, { resolve: false }));
    }
    return externals;
}
// do we need to do this ahead of time or could we do it lazily?
function collectExternals(root, preserveSymlinks, ssrExternals, seen, logger) {
    var _a;
    const rootPkgContent = lookupFile(root, ['package.json']);
    if (!rootPkgContent) {
        return;
    }
    const rootPkg = JSON.parse(rootPkgContent);
    const deps = {
        ...rootPkg.devDependencies,
        ...rootPkg.dependencies
    };
    const resolveOptions = {
        root,
        preserveSymlinks,
        isProduction: false,
        isBuild: true
    };
    const depsToTrace = new Set();
    for (const id in deps) {
        if (seen.has(id))
            continue;
        seen.add(id);
        let esmEntry;
        let requireEntry;
        try {
            esmEntry = (_a = tryNodeResolve(id, undefined, resolveOptions, true, // we set `targetWeb` to `true` to get the ESM entry
            undefined, true)) === null || _a === void 0 ? void 0 : _a.id;
            // normalizePath required for windows. tryNodeResolve uses normalizePath
            // which returns with '/', require.resolve returns with '\\'
            requireEntry = normalizePath(require.resolve(id, { paths: [root] }));
        }
        catch (e) {
            try {
                // no main entry, but deep imports may be allowed
                const pkgPath = resolveFrom(`${id}/package.json`, root);
                if (pkgPath.includes('node_modules')) {
                    ssrExternals.add(id);
                }
                else {
                    depsToTrace.add(path.dirname(pkgPath));
                }
                continue;
            }
            catch { }
            // resolve failed, assume include
            debug$1(`Failed to resolve entries for package "${id}"\n`, e);
            continue;
        }
        // no esm entry but has require entry
        if (!esmEntry) {
            ssrExternals.add(id);
        }
        // trace the dependencies of linked packages
        else if (!esmEntry.includes('node_modules')) {
            const pkgPath = resolveFrom(`${id}/package.json`, root);
            depsToTrace.add(path.dirname(pkgPath));
        }
        // has separate esm/require entry, assume require entry is cjs
        else if (esmEntry !== requireEntry) {
            ssrExternals.add(id);
        }
        // if we're externalizing ESM and CJS should basically just always do it?
        // or are there others like SystemJS / AMD that we'd need to handle?
        // for now, we'll just leave this as is
        else if (/\.m?js$/.test(esmEntry)) {
            const pkgPath = resolveFrom(`${id}/package.json`, root);
            const pkgContent = fs.readFileSync(pkgPath, 'utf-8');
            if (!pkgContent) {
                continue;
            }
            const pkg = JSON.parse(pkgContent);
            if (pkg.type === 'module' || esmEntry.endsWith('.mjs')) {
                ssrExternals.add(id);
                continue;
            }
            // check if the entry is cjs
            const content = fs.readFileSync(esmEntry, 'utf-8');
            if (/\bmodule\.exports\b|\bexports[.\[]|\brequire\s*\(/.test(content)) {
                ssrExternals.add(id);
                continue;
            }
            logger.warn(`${id} is incorrectly packaged. Please contact the package author to fix.`);
        }
    }
    for (const depRoot of depsToTrace) {
        collectExternals(depRoot, preserveSymlinks, ssrExternals, seen, logger);
    }
}
function shouldExternalizeForSSR(id, externals) {
    const should = externals.some((e) => {
        if (id === e) {
            return true;
        }
        // deep imports, check ext before externalizing - only externalize
        // extension-less imports and explicit .js imports
        if (id.startsWith(e + '/') && (!path.extname(id) || id.endsWith('.js'))) {
            return true;
        }
    });
    return should;
}
function getNpmPackageName(importPath) {
    const parts = importPath.split('/');
    if (parts[0].startsWith('@')) {
        if (!parts[1])
            return null;
        return `${parts[0]}/${parts[1]}`;
    }
    else {
        return parts[0];
    }
}

function buildErrorMessage(err, args = [], includeStack = true) {
    if (err.plugin)
        args.push(`  Plugin: ${p.magenta(err.plugin)}`);
    if (err.id)
        args.push(`  File: ${p.cyan(err.id)}`);
    if (err.frame)
        args.push(p.yellow(pad(err.frame)));
    if (includeStack && err.stack)
        args.push(pad(cleanStack(err.stack)));
    return args.join('\n');
}
function cleanStack(stack) {
    return stack
        .split(/\n/g)
        .filter((l) => /^\s*at/.test(l))
        .join('\n');
}

/**
 * This file is refactored into TypeScript based on
 * https://github.com/preactjs/wmr/blob/main/packages/wmr/src/lib/rollup-plugin-container.js
 */
let parser = acorn.Parser.extend(acornClassFields, acornStaticClassFeatures);
async function createPluginContainer({ plugins, logger, root, build: { rollupOptions } }, moduleGraph, watcher) {
    // ---------------------------------------------------------------------------
    const watchFiles = new Set();
    // get rollup version
    const minimalContext = {
        meta: {
            rollupVersion: '2.38.5',
            watchMode: true
        }
    };
    function warnIncompatibleMethod(method, plugin) {
        logger.warn(p.cyan(`[plugin:${plugin}] `) +
            p.yellow(`context method ${p.bold(`${method}()`)} is not supported in serve mode. This plugin is likely not vite-compatible.`));
    }
    // throw when an unsupported ModuleInfo property is accessed,
    // so that incompatible plugins fail in a non-cryptic way.
    const ModuleInfoProxy = {
        get(info, key) {
            if (key in info) {
                return info[key];
            }
            throw Error(`[vite] The "${key}" property of ModuleInfo is not supported.`);
        }
    };
    // same default value of "moduleInfo.meta" as in Rollup
    const EMPTY_OBJECT = Object.freeze({});
    function getModuleInfo(id) {
        const module = moduleGraph === null || moduleGraph === void 0 ? void 0 : moduleGraph.getModuleById(id);
        if (!module) {
            return null;
        }
        if (!module.info) {
            module.info = new Proxy({ id, meta: module.meta || EMPTY_OBJECT }, ModuleInfoProxy);
        }
        return module.info;
    }
    function updateModuleInfo(id, { meta }) {
        if (meta) {
            const moduleInfo = getModuleInfo(id);
            if (moduleInfo) {
                moduleInfo.meta = { ...moduleInfo.meta, ...meta };
            }
        }
    }
    // we should create a new context for each async hook pipeline so that the
    // active plugin in that pipeline can be tracked in a concurrency-safe manner.
    // using a class to make creating new contexts more efficient
    class Context {
        constructor(initialPlugin) {
            this.meta = minimalContext.meta;
            this.ssr = false;
            this._activeId = null;
            this._activeCode = null;
            this._addedImports = null;
            this._activePlugin = initialPlugin || null;
        }
        parse(code, opts = {}) {
            return parser.parse(code, {
                sourceType: 'module',
                ecmaVersion: 'latest',
                locations: true,
                ...opts
            });
        }
        async resolve(id, importer, options) {
            let skip;
            if ((options === null || options === void 0 ? void 0 : options.skipSelf) && this._activePlugin) {
                skip = new Set(this._resolveSkips);
                skip.add(this._activePlugin);
            }
            let out = await container.resolveId(id, importer, { skip, ssr: this.ssr });
            if (typeof out === 'string')
                out = { id: out };
            return out;
        }
        getModuleInfo(id) {
            return getModuleInfo(id);
        }
        getModuleIds() {
            return moduleGraph
                ? moduleGraph.idToModuleMap.keys()
                : Array.prototype[Symbol.iterator]();
        }
        addWatchFile(id) {
            watchFiles.add(id);
            (this._addedImports || (this._addedImports = new Set())).add(id);
            if (watcher)
                ensureWatchedFile(watcher, id, root);
        }
        getWatchFiles() {
            return [...watchFiles];
        }
        emitFile(assetOrFile) {
            warnIncompatibleMethod(`emitFile`, this._activePlugin.name);
            return '';
        }
        setAssetSource() {
            warnIncompatibleMethod(`setAssetSource`, this._activePlugin.name);
        }
        getFileName() {
            warnIncompatibleMethod(`getFileName`, this._activePlugin.name);
            return '';
        }
        warn(e, position) {
            const err = formatError(e, position, this);
            const msg = buildErrorMessage(err, [p.yellow(`warning: ${err.message}`)], false);
            logger.warn(msg, {
                clear: true,
                timestamp: true
            });
        }
        error(e, position) {
            // error thrown here is caught by the transform middleware and passed on
            // the the error middleware.
            throw formatError(e, position, this);
        }
    }
    function formatError(e, position, ctx) {
        const err = (typeof e === 'string' ? new Error(e) : e);
        if (ctx._activePlugin)
            err.plugin = ctx._activePlugin.name;
        if (ctx._activeId && !err.id)
            err.id = ctx._activeId;
        if (ctx._activeCode) {
            err.pluginCode = ctx._activeCode;
            const pos = position != null
                ? position
                : err.pos != null
                    ? err.pos
                    : // some rollup plugins, e.g. json, sets position instead of pos
                        err.position;
            if (pos != null) {
                let errLocation;
                try {
                    errLocation = numberToPos(ctx._activeCode, pos);
                }
                catch (err2) {
                    logger.error(p.red(`Error in error handler:\n${err2.stack || err2.message}\n`), 
                    // print extra newline to separate the two errors
                    { error: err2 });
                    throw err;
                }
                err.loc = err.loc || {
                    file: err.id,
                    ...errLocation
                };
                err.frame = err.frame || generateCodeFrame(ctx._activeCode, pos);
            }
            else if (err.loc) {
                // css preprocessors may report errors in an included file
                if (!err.frame) {
                    let code = ctx._activeCode;
                    if (err.loc.file) {
                        err.id = normalizePath(err.loc.file);
                        try {
                            code = fs.readFileSync(err.loc.file, 'utf-8');
                        }
                        catch { }
                    }
                    err.frame = generateCodeFrame(code, err.loc);
                }
            }
            else if (err.line && err.column) {
                err.loc = {
                    file: err.id,
                    line: err.line,
                    column: err.column
                };
                err.frame = err.frame || generateCodeFrame(ctx._activeCode, err.loc);
            }
        }
        return err;
    }
    class TransformContext extends Context {
        constructor(filename, code, inMap) {
            super();
            this.originalSourcemap = null;
            this.sourcemapChain = [];
            this.combinedMap = null;
            this.filename = filename;
            this.originalCode = code;
            if (inMap) {
                this.sourcemapChain.push(inMap);
            }
        }
        _getCombinedSourcemap(createIfNull = false) {
            let combinedMap = this.combinedMap;
            for (let m of this.sourcemapChain) {
                if (typeof m === 'string')
                    m = JSON.parse(m);
                if (!('version' in m)) {
                    // empty, nullified source map
                    combinedMap = this.combinedMap = null;
                    this.sourcemapChain.length = 0;
                    break;
                }
                if (!combinedMap) {
                    combinedMap = m;
                }
                else {
                    combinedMap = combineSourcemaps(this.filename, [
                        {
                            ...m,
                            sourcesContent: combinedMap.sourcesContent
                        },
                        combinedMap
                    ]);
                }
            }
            if (!combinedMap) {
                return createIfNull
                    ? new MagicString(this.originalCode).generateMap({
                        includeContent: true,
                        hires: true,
                        source: this.filename
                    })
                    : null;
            }
            if (combinedMap !== this.combinedMap) {
                this.combinedMap = combinedMap;
                this.sourcemapChain.length = 0;
            }
            return this.combinedMap;
        }
        getCombinedSourcemap() {
            return this._getCombinedSourcemap(true);
        }
    }
    let closed = false;
    const container = {
        options: await (async () => {
            let options = rollupOptions;
            for (const plugin of plugins) {
                if (!plugin.options)
                    continue;
                options =
                    (await plugin.options.call(minimalContext, options)) || options;
            }
            if (options.acornInjectPlugins) {
                parser = acorn.Parser.extend(...[acornClassFields, acornStaticClassFeatures].concat(options.acornInjectPlugins));
            }
            return {
                acorn,
                acornInjectPlugins: [],
                ...options
            };
        })(),
        getModuleInfo,
        async buildStart() {
            await Promise.all(plugins.map((plugin) => {
                if (plugin.buildStart) {
                    return plugin.buildStart.call(new Context(plugin), container.options);
                }
            }));
        },
        async resolveId(rawId, importer = join(root, 'index.html'), options) {
            const skip = options === null || options === void 0 ? void 0 : options.skip;
            const ssr = options === null || options === void 0 ? void 0 : options.ssr;
            const ctx = new Context();
            ctx.ssr = !!ssr;
            ctx._resolveSkips = skip;
            let id = null;
            const partial = {};
            for (const plugin of plugins) {
                if (!plugin.resolveId)
                    continue;
                if (skip === null || skip === void 0 ? void 0 : skip.has(plugin))
                    continue;
                ctx._activePlugin = plugin;
                const result = await plugin.resolveId.call(ctx, rawId, importer, { ssr });
                if (!result)
                    continue;
                if (typeof result === 'string') {
                    id = result;
                }
                else {
                    id = result.id;
                    Object.assign(partial, result);
                }
                // resolveId() is hookFirst - first non-null result is returned.
                break;
            }
            if (id) {
                partial.id = isExternalUrl(id) ? id : normalizePath(id);
                return partial;
            }
            else {
                return null;
            }
        },
        async load(id, options) {
            const ssr = options === null || options === void 0 ? void 0 : options.ssr;
            const ctx = new Context();
            ctx.ssr = !!ssr;
            for (const plugin of plugins) {
                if (!plugin.load)
                    continue;
                ctx._activePlugin = plugin;
                let result;
                try {
                    result = await plugin.load.call(ctx, id, { ssr });
                }
                catch (e) {
                    ctx.error(e);
                }
                if (result != null) {
                    if (isObject(result)) {
                        updateModuleInfo(id, result);
                    }
                    return result;
                }
            }
            return null;
        },
        async transform(code, id, options) {
            const inMap = options === null || options === void 0 ? void 0 : options.inMap;
            const ssr = options === null || options === void 0 ? void 0 : options.ssr;
            const ctx = new TransformContext(id, code, inMap);
            ctx.ssr = !!ssr;
            for (const plugin of plugins) {
                if (!plugin.transform)
                    continue;
                ctx._activePlugin = plugin;
                ctx._activeId = id;
                ctx._activeCode = code;
                let result;
                try {
                    result = await plugin.transform.call(ctx, code, id, { ssr });
                }
                catch (e) {
                    ctx.error(e);
                }
                if (!result)
                    continue;
                if (isObject(result)) {
                    if (result.code !== undefined) {
                        code = result.code;
                        if (result.map) {
                            ctx.sourcemapChain.push(result.map);
                        }
                    }
                    updateModuleInfo(id, result);
                }
                else {
                    code = result;
                }
            }
            return {
                code,
                map: ctx._getCombinedSourcemap()
            };
        },
        async close() {
            if (closed)
                return;
            const ctx = new Context();
            await Promise.all(plugins.map((p) => p.buildEnd && p.buildEnd.call(ctx)));
            await Promise.all(plugins.map((p) => p.closeBundle && p.closeBundle.call(ctx)));
            closed = true;
        }
    };
    return container;
}

const debug = createDebugger('vite:deps');
const htmlTypesRE = /\.(html|vue|svelte|astro)$/;
const setupRE = /<script\s+setup/;
// A simple regex to detect import sources. This is only used on
// <script lang="ts"> blocks in vue (setup only) or svelte files, since
// seemingly unused imports are dropped by esbuild when transpiling TS which
// prevents it from crawling further.
// We can't use es-module-lexer because it can't handle TS, and don't want to
// use Acorn because it's slow. Luckily this doesn't have to be bullet proof
// since even missed imports can be caught at runtime, and false positives will
// simply be ignored.
// BROWSER VITE patch: no lookbehind for safari support
const importsRE = /(?:^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from\s*)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\*)/gm;
async function scanImports(config) {
    var _a, _b, _c;
    const start = performance.now();
    let entries = [];
    const explicitEntryPatterns = config.optimizeDeps.entries;
    const buildInput = (_a = config.build.rollupOptions) === null || _a === void 0 ? void 0 : _a.input;
    if (explicitEntryPatterns) {
        entries = await globEntries(explicitEntryPatterns, config);
    }
    else if (buildInput) {
        const resolvePath = (p) => path.resolve(config.root, p);
        if (typeof buildInput === 'string') {
            entries = [resolvePath(buildInput)];
        }
        else if (Array.isArray(buildInput)) {
            entries = buildInput.map(resolvePath);
        }
        else if (isObject(buildInput)) {
            entries = Object.values(buildInput).map(resolvePath);
        }
        else {
            throw new Error('invalid rollupOptions.input value.');
        }
    }
    else {
        entries = await globEntries('**/*.html', config);
    }
    // Non-supported entry file types and virtual files should not be scanned for
    // dependencies.
    entries = entries.filter((entry) => 
    // BROWSER VITE patch: we want to parse md/mdx files as well with an injected plugin
    // (JS_TYPES_RE.test(entry) || htmlTypesRE.test(entry)) &&
    fs.existsSync(entry));
    if (!entries.length) {
        if (!explicitEntryPatterns && !config.optimizeDeps.include) {
            config.logger.warn(p.yellow('(!) Could not auto-determine entry point from rollupOptions or html files ' +
                'and there are no explicit optimizeDeps.include patterns. ' +
                'Skipping dependency pre-bundling.'));
        }
        return { deps: {}, missing: {} };
    }
    else {
        debug(`Crawling dependencies using entries:\n  ${entries.join('\n  ')}`);
    }
    const deps = {};
    const missing = {};
    const container = await createPluginContainer(config);
    const plugin = esbuildScanPlugin(config, container, deps, missing, entries);
    const { plugins = [], ...esbuildOptions } = (_c = (_b = config.optimizeDeps) === null || _b === void 0 ? void 0 : _b.esbuildOptions) !== null && _c !== void 0 ? _c : {};
    // BROWSER VITE patch: single build for all entries
    await build({
        absWorkingDir: process.cwd(),
        outdir: path.join(process.cwd(), 'dist'),
        write: false,
        entryPoints: entries,
        bundle: true,
        format: 'esm',
        logLevel: 'error',
        plugins: [...plugins, plugin],
        ...esbuildOptions
    });
    debug(`Scan completed in ${(performance.now() - start).toFixed(2)}ms:`, deps);
    return {
        deps,
        missing
    };
}
function globEntries(pattern, config) {
    return glob(pattern, {
        cwd: config.root,
        ignore: [
            '**/node_modules/**',
            `**/${config.build.outDir}/**`,
            `**/__tests__/**`
        ],
        absolute: true
    });
}
const scriptModuleRE = /(<script\b[^>]*type\s*=\s*(?:"module"|'module')[^>]*>)(.*?)<\/script>/gims;
const scriptRE = /(<script\b(?:\s[^>]*>|>))(.*?)<\/script>/gims;
const commentRE = /<!--(.|[\r\n])*?-->/;
const srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
const typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
const langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
const contextRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
function esbuildScanPlugin(config, container, depImports, missing, entries) {
    var _a, _b;
    const seen = new Map();
    const resolve = async (id, importer) => {
        const key = id + (importer && path.dirname(importer));
        if (seen.has(key)) {
            return seen.get(key);
        }
        const resolved = await container.resolveId(id, importer && normalizePath(importer));
        const res = resolved === null || resolved === void 0 ? void 0 : resolved.id;
        seen.set(key, res);
        return res;
    };
    const include = (_a = config.optimizeDeps) === null || _a === void 0 ? void 0 : _a.include;
    const exclude = [
        ...(((_b = config.optimizeDeps) === null || _b === void 0 ? void 0 : _b.exclude) || []),
        '@vite/client',
        '@vite/env'
    ];
    const externalUnlessEntry = ({ path }) => ({
        path,
        external: !entries.includes(path)
    });
    return {
        name: 'vite:dep-scan',
        setup(build) {
            const localScripts = {};
            // external urls
            build.onResolve({ filter: externalRE }, ({ path }) => ({
                path,
                external: true
            }));
            // data urls
            build.onResolve({ filter: dataUrlRE }, ({ path }) => ({
                path,
                external: true
            }));
            // local scripts (`<script>` in Svelte and `<script setup>` in Vue)
            build.onResolve({ filter: virtualModuleRE }, ({ path }) => {
                return {
                    // strip prefix to get valid filesystem path so esbuild can resolve imports in the file
                    path: path.replace(virtualModulePrefix, ''),
                    namespace: 'local-script'
                };
            });
            build.onLoad({ filter: /.*/, namespace: 'local-script' }, ({ path }) => {
                return localScripts[path];
            });
            // html types: extract script contents -----------------------------------
            build.onResolve({ filter: htmlTypesRE }, async ({ path, importer }) => {
                return {
                    path: await resolve(path, importer),
                    namespace: 'html'
                };
            });
            // extract scripts inside HTML-like files and treat it as a js module
            build.onLoad({ filter: htmlTypesRE, namespace: 'html' }, async ({ path }) => {
                let raw = fs.readFileSync(path, 'utf-8');
                // Avoid matching the content of the comment
                raw = raw.replace(commentRE, '<!---->');
                const isHtml = path.endsWith('.html');
                const regex = isHtml ? scriptModuleRE : scriptRE;
                regex.lastIndex = 0;
                let js = '';
                let loader = 'js';
                let match;
                while ((match = regex.exec(raw))) {
                    const [, openTag, content] = match;
                    const typeMatch = openTag.match(typeRE);
                    const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
                    const langMatch = openTag.match(langRE);
                    const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
                    // skip type="application/ld+json" and other non-JS types
                    if (type &&
                        !(type.includes('javascript') ||
                            type.includes('ecmascript') ||
                            type === 'module')) {
                        continue;
                    }
                    if (lang === 'ts' || lang === 'tsx' || lang === 'jsx') {
                        loader = lang;
                    }
                    const srcMatch = openTag.match(srcRE);
                    if (srcMatch) {
                        const src = srcMatch[1] || srcMatch[2] || srcMatch[3];
                        js += `import ${JSON.stringify(src)}\n`;
                    }
                    else if (content.trim()) {
                        // There can be module scripts (`<script context="module">` in Svelte and `<script>` in Vue)
                        // or local scripts (`<script>` in Svelte and `<script setup>` in Vue)
                        // We need to handle these separately in case variable names are reused between them
                        const contextMatch = openTag.match(contextRE);
                        const context = contextMatch &&
                            (contextMatch[1] || contextMatch[2] || contextMatch[3]);
                        if ((path.endsWith('.vue') && setupRE.test(openTag)) ||
                            (path.endsWith('.svelte') && context !== 'module')) {
                            // append imports in TS to prevent esbuild from removing them
                            // since they may be used in the template
                            const localContent = content +
                                (loader.startsWith('ts') ? extractImportPaths(content) : '');
                            localScripts[path] = {
                                loader,
                                contents: localContent
                            };
                            js += `import '${virtualModulePrefix}${path}';\n`;
                        }
                        else {
                            js += content + '\n';
                        }
                    }
                }
                // `<script>` in Svelte has imports that can be used in the template
                // so we handle them here too
                if (loader.startsWith('ts') && path.endsWith('.svelte')) {
                    js += extractImportPaths(js);
                }
                // This will trigger incorrectly if `export default` is contained
                // anywhere in a string. Svelte and Astro files can't have
                // `export default` as code so we know if it's encountered it's a
                // false positive (e.g. contained in a string)
                if (!path.endsWith('.vue') || !js.includes('export default')) {
                    js += '\nexport default {}';
                }
                if (js.includes('import.meta.glob')) {
                    return {
                        // transformGlob already transforms to js
                        loader: 'js',
                        contents: await transformGlob(js, path, config.root, loader)
                    };
                }
                return {
                    loader,
                    contents: js
                };
            });
            // bare imports: record and externalize ----------------------------------
            build.onResolve({
                // avoid matching windows volume
                filter: /^[\w@][^:]/
            }, async ({ path: id, importer }) => {
                if (moduleListContains(exclude, id)) {
                    return externalUnlessEntry({ path: id });
                }
                if (depImports[id]) {
                    return externalUnlessEntry({ path: id });
                }
                const resolved = await resolve(id, importer);
                if (resolved) {
                    if (shouldExternalizeDep(resolved, id)) {
                        return externalUnlessEntry({ path: id });
                    }
                    if (resolved.includes('node_modules') || (include === null || include === void 0 ? void 0 : include.includes(id))) {
                        // dependency or forced included, externalize and stop crawling
                        if (OPTIMIZABLE_ENTRY_RE.test(resolved)) {
                            depImports[id] = resolved;
                        }
                        return externalUnlessEntry({ path: id });
                    }
                    else {
                        const namespace = htmlTypesRE.test(resolved) ? 'html' : undefined;
                        // linked package, keep crawling
                        return {
                            path: path.resolve(resolved),
                            namespace
                        };
                    }
                }
                else {
                    missing[id] = normalizePath(importer);
                }
            });
            // Externalized file types -----------------------------------------------
            // these are done on raw ids using esbuild's native regex filter so it
            // should be faster than doing it in the catch-all via js
            // they are done after the bare import resolve because a package name
            // may end with these extensions
            // css & json
            build.onResolve({
                filter: /\.(css|less|sass|scss|styl|stylus|pcss|postcss|json)$/
            }, externalUnlessEntry);
            // known asset types
            build.onResolve({
                filter: new RegExp(`\\.(${KNOWN_ASSET_TYPES.join('|')})$`)
            }, externalUnlessEntry);
            // known vite query types: ?worker, ?raw
            build.onResolve({ filter: SPECIAL_QUERY_RE }, ({ path }) => ({
                path,
                external: true
            }));
            // catch all -------------------------------------------------------------
            build.onResolve({
                filter: /.*/
            }, async ({ path: id, importer }) => {
                // use vite resolver to support urls and omitted extensions
                const resolved = await resolve(id, importer);
                if (resolved) {
                    if (shouldExternalizeDep(resolved, id)) {
                        return externalUnlessEntry({ path: id });
                    }
                    const namespace = htmlTypesRE.test(resolved) ? 'html' : undefined;
                    return {
                        path: path.resolve(cleanUrl(resolved)),
                        namespace
                    };
                }
                else {
                    // resolve failed... probably unsupported type
                    return externalUnlessEntry({ path: id });
                }
            });
            // for jsx/tsx, we need to access the content and check for
            // presence of import.meta.glob, since it results in import relationships
            // but isn't crawled by esbuild.
            build.onLoad({ filter: JS_TYPES_RE }, ({ path: id }) => {
                let ext = path.extname(id).slice(1);
                if (ext === 'mjs')
                    ext = 'js';
                let contents = fs.readFileSync(id, 'utf-8');
                if (ext.endsWith('x') && config.esbuild && config.esbuild.jsxInject) {
                    contents = config.esbuild.jsxInject + `\n` + contents;
                }
                if (contents.includes('import.meta.glob')) {
                    return transformGlob(contents, id, config.root, ext).then((contents) => ({
                        loader: ext,
                        contents
                    }));
                }
                return {
                    loader: ext,
                    contents
                };
            });
        }
    };
}
async function transformGlob(source, importer, root, loader) {
    // transform the content first since es-module-lexer can't handle non-js
    if (loader !== 'js') {
        source = (await transform(source, { loader })).code;
    }
    await init;
    const imports = parse$2(source)[0];
    const s = new MagicString(source);
    for (let index = 0; index < imports.length; index++) {
        const { s: start, e: end, ss: expStart } = imports[index];
        const url = source.slice(start, end);
        if (url !== 'import.meta')
            continue;
        if (source.slice(end, end + 5) !== '.glob')
            continue;
        const { importsString, exp, endIndex } = await transformImportGlob(source, start, normalizePath(importer), index, root);
        s.prepend(importsString);
        s.overwrite(expStart, endIndex, exp);
    }
    return s.toString();
}
/**
 * when using TS + (Vue + `<script setup>`) or Svelte, imports may seem
 * unused to esbuild and dropped in the build output, which prevents
 * esbuild from crawling further.
 * the solution is to add `import 'x'` for every source to force
 * esbuild to keep crawling due to potential side effects.
 */
function extractImportPaths(code) {
    // empty singleline & multiline comments to avoid matching comments
    code = code
        .replace(multilineCommentsRE, '/* */')
        .replace(singlelineCommentsRE, '');
    let js = '';
    let m;
    while ((m = importsRE.exec(code)) != null) {
        // This is necessary to avoid infinite loops with zero-width matches
        if (m.index === importsRE.lastIndex) {
            importsRE.lastIndex++;
        }
        js += `\nimport ${m[1]}`;
    }
    return js;
}
function shouldExternalizeDep(resolvedId, rawId) {
    // not a valid file path
    if (!path.isAbsolute(resolvedId)) {
        return true;
    }
    // virtual id
    if (resolvedId === rawId || resolvedId.includes('\0')) {
        return true;
    }
    // resolved is not a scannable type
    if (!JS_TYPES_RE.test(resolvedId) && !htmlTypesRE.test(resolvedId)) {
        return true;
    }
    return false;
}

function resolveBuildOptions(root, raw) {
    var _a;
    const resolved = {
        target: 'modules',
        polyfillModulePreload: true,
        outDir: 'dist',
        assetsDir: 'assets',
        assetsInlineLimit: 4096,
        cssCodeSplit: !(raw === null || raw === void 0 ? void 0 : raw.lib),
        cssTarget: false,
        sourcemap: false,
        rollupOptions: {},
        minify: (raw === null || raw === void 0 ? void 0 : raw.ssr) ? false : 'esbuild',
        terserOptions: {},
        write: true,
        emptyOutDir: null,
        manifest: false,
        lib: false,
        ssr: false,
        ssrManifest: false,
        reportCompressedSize: true,
        // brotliSize: true,
        chunkSizeWarningLimit: 500,
        watch: null,
        ...raw,
        commonjsOptions: {
            include: [/node_modules/],
            extensions: ['.js', '.cjs'],
            ...raw === null || raw === void 0 ? void 0 : raw.commonjsOptions
        },
        dynamicImportVarsOptions: {
            warnOnError: true,
            exclude: [/node_modules/],
            ...raw === null || raw === void 0 ? void 0 : raw.dynamicImportVarsOptions
        }
    };
    const resolve = (p) => p.startsWith('\0') ? p : path.resolve(root, p);
    resolved.outDir = resolve(resolved.outDir);
    let input;
    if ((_a = raw === null || raw === void 0 ? void 0 : raw.rollupOptions) === null || _a === void 0 ? void 0 : _a.input) {
        input = Array.isArray(raw.rollupOptions.input)
            ? raw.rollupOptions.input.map((input) => resolve(input))
            : typeof raw.rollupOptions.input === 'object'
                ? Object.fromEntries(Object.entries(raw.rollupOptions.input).map(([key, value]) => [
                    key,
                    resolve(value)
                ]))
                : resolve(raw.rollupOptions.input);
    }
    else {
        input = resolve((raw === null || raw === void 0 ? void 0 : raw.lib)
            ? raw.lib.entry
            : typeof (raw === null || raw === void 0 ? void 0 : raw.ssr) === 'string'
                ? raw.ssr
                : 'index.html');
    }
    if (!!(raw === null || raw === void 0 ? void 0 : raw.ssr) && typeof input === 'string' && input.endsWith('.html')) {
        throw new Error(`rollupOptions.input should not be an html file when building for SSR. ` +
            `Please specify a dedicated SSR entry.`);
    }
    resolved.rollupOptions.input = input;
    // handle special build targets
    if (resolved.target === 'modules') {
        // Support browserslist
        // "defaults and supports es6-module and supports es6-module-dynamic-import",
        resolved.target = [
            'es2019',
            'edge88',
            'firefox78',
            'chrome87',
            'safari13.1'
        ];
    }
    else if (resolved.target === 'esnext' && resolved.minify === 'terser') {
        // esnext + terser: limit to es2019 so it can be minified by terser
        resolved.target = 'es2019';
    }
    if (!resolved.cssTarget) {
        resolved.cssTarget = resolved.target;
    }
    // normalize false string into actual false
    if (resolved.minify === 'false') {
        resolved.minify = false;
    }
    if (resolved.minify === true) {
        resolved.minify = 'esbuild';
    }
    return resolved;
}

const ssrModuleExportsKey = `__vite_ssr_exports__`;
const ssrImportKey = `__vite_ssr_import__`;
const ssrDynamicImportKey = `__vite_ssr_dynamic_import__`;
const ssrExportAllKey = `__vite_ssr_exportAll__`;
const ssrImportMetaKey = `__vite_ssr_import_meta__`;
async function ssrTransform(code, inMap, url) {
    const s = new MagicString(code);
    let ast;
    try {
        ast = parser.parse(code, {
            sourceType: 'module',
            ecmaVersion: 'latest',
            locations: true
        });
    }
    catch (err) {
        if (!err.loc || !err.loc.line)
            throw err;
        const line = err.loc.line;
        throw new Error(`Parse failure: ${err.message}\nContents of line ${line}: ${code.split('\n')[line - 1]}`);
    }
    let uid = 0;
    const deps = new Set();
    const dynamicDeps = new Set();
    const idToImportMap = new Map();
    const declaredConst = new Set();
    function defineImport(node, source) {
        deps.add(source);
        const importId = `__vite_ssr_import_${uid++}__`;
        s.appendLeft(node.start, `const ${importId} = await ${ssrImportKey}(${JSON.stringify(source)});\n`);
        return importId;
    }
    function defineExport(position, name, local = name) {
        s.appendRight(position, `\nObject.defineProperty(${ssrModuleExportsKey}, "${name}", ` +
            `{ enumerable: true, configurable: true, get(){ return ${local} }});`);
    }
    // 1. check all import statements and record id -> importName map
    for (const node of ast.body) {
        // import foo from 'foo' --> foo -> __import_foo__.default
        // import { baz } from 'foo' --> baz -> __import_foo__.baz
        // import * as ok from 'foo' --> ok -> __import_foo__
        if (node.type === 'ImportDeclaration') {
            const importId = defineImport(node, node.source.value);
            for (const spec of node.specifiers) {
                if (spec.type === 'ImportSpecifier') {
                    idToImportMap.set(spec.local.name, `${importId}.${spec.imported.name}`);
                }
                else if (spec.type === 'ImportDefaultSpecifier') {
                    idToImportMap.set(spec.local.name, `${importId}.default`);
                }
                else {
                    // namespace specifier
                    idToImportMap.set(spec.local.name, importId);
                }
            }
            s.remove(node.start, node.end);
        }
    }
    // 2. check all export statements and define exports
    for (const node of ast.body) {
        // named exports
        if (node.type === 'ExportNamedDeclaration') {
            if (node.declaration) {
                if (node.declaration.type === 'FunctionDeclaration' ||
                    node.declaration.type === 'ClassDeclaration') {
                    // export function foo() {}
                    defineExport(node.end, node.declaration.id.name);
                }
                else {
                    // export const foo = 1, bar = 2
                    for (const declaration of node.declaration.declarations) {
                        const names = extract_names(declaration.id);
                        for (const name of names) {
                            defineExport(node.end, name);
                        }
                    }
                }
                s.remove(node.start, node.declaration.start);
            }
            else {
                s.remove(node.start, node.end);
                if (node.source) {
                    // export { foo, bar } from './foo'
                    const importId = defineImport(node, node.source.value);
                    for (const spec of node.specifiers) {
                        defineExport(node.end, spec.exported.name, `${importId}.${spec.local.name}`);
                    }
                }
                else {
                    // export { foo, bar }
                    for (const spec of node.specifiers) {
                        const local = spec.local.name;
                        const binding = idToImportMap.get(local);
                        defineExport(node.end, spec.exported.name, binding || local);
                    }
                }
            }
        }
        // default export
        if (node.type === 'ExportDefaultDeclaration') {
            if ('id' in node.declaration && node.declaration.id) {
                // named hoistable/class exports
                // export default function foo() {}
                // export default class A {}
                const { name } = node.declaration.id;
                s.remove(node.start, node.start + 15 /* 'export default '.length */);
                s.append(`\nObject.defineProperty(${ssrModuleExportsKey}, "default", ` +
                    `{ enumerable: true, value: ${name} });`);
            }
            else {
                // anonymous default exports
                s.overwrite(node.start, node.start + 14 /* 'export default'.length */, `${ssrModuleExportsKey}.default =`);
            }
        }
        // export * from './foo'
        if (node.type === 'ExportAllDeclaration') {
            if (node.exported) {
                const importId = defineImport(node, node.source.value);
                s.remove(node.start, node.end);
                defineExport(node.end, node.exported.name, `${importId}`);
            }
            else {
                const importId = defineImport(node, node.source.value);
                s.remove(node.start, node.end);
                s.appendLeft(node.end, `${ssrExportAllKey}(${importId});`);
            }
        }
    }
    // 3. convert references to import bindings & import.meta references
    walk(ast, {
        onIdentifier(id, parent, parentStack) {
            const binding = idToImportMap.get(id.name);
            if (!binding) {
                return;
            }
            if (isStaticProperty(parent) && parent.shorthand) {
                // let binding used in a property shorthand
                // { foo } -> { foo: __import_x__.foo }
                // skip for destructuring patterns
                if (!parent.inPattern ||
                    isInDestructuringAssignment(parent, parentStack)) {
                    s.appendLeft(id.end, `: ${binding}`);
                }
            }
            else if (parent.type === 'ClassDeclaration' &&
                id === parent.superClass) {
                if (!declaredConst.has(id.name)) {
                    declaredConst.add(id.name);
                    // locate the top-most node containing the class declaration
                    const topNode = parentStack[1];
                    s.prependRight(topNode.start, `const ${id.name} = ${binding};\n`);
                }
            }
            else {
                s.overwrite(id.start, id.end, binding);
            }
        },
        onImportMeta(node) {
            s.overwrite(node.start, node.end, ssrImportMetaKey);
        },
        onDynamicImport(node) {
            s.overwrite(node.start, node.start + 6, ssrDynamicImportKey);
            if (node.type === 'ImportExpression' && node.source.type === 'Literal') {
                dynamicDeps.add(node.source.value);
            }
        }
    });
    let map = s.generateMap({ hires: true });
    if (inMap && inMap.mappings && inMap.sources.length > 0) {
        map = combineSourcemaps(url, [
            {
                ...map,
                sources: inMap.sources,
                sourcesContent: inMap.sourcesContent
            },
            inMap
        ]);
    }
    else {
        map.sources = [url];
        map.sourcesContent = [code];
    }
    return {
        code: s.toString(),
        map,
        deps: [...deps],
        dynamicDeps: [...dynamicDeps]
    };
}
/**
 * Same logic from \@vue/compiler-core & \@vue/compiler-sfc
 * Except this is using acorn AST
 */
function walk(root, { onIdentifier, onImportMeta, onDynamicImport }) {
    const parentStack = [];
    const scope = Object.create(null);
    const scopeMap = new WeakMap();
    const setScope = (node, name) => {
        let scopeIds = scopeMap.get(node);
        if (scopeIds && scopeIds.has(name)) {
            return;
        }
        if (name in scope) {
            scope[name]++;
        }
        else {
            scope[name] = 1;
        }
        if (!scopeIds) {
            scopeIds = new Set();
            scopeMap.set(node, scopeIds);
        }
        scopeIds.add(name);
    };
    walk$1(root, {
        enter(node, parent) {
            if (node.type === 'ImportDeclaration') {
                return this.skip();
            }
            parent && parentStack.push(parent);
            if (node.type === 'MetaProperty' && node.meta.name === 'import') {
                onImportMeta(node);
            }
            else if (node.type === 'ImportExpression') {
                onDynamicImport(node);
            }
            if (node.type === 'Identifier') {
                if (!scope[node.name] && isRefIdentifier(node, parent, parentStack)) {
                    onIdentifier(node, parent, parentStack);
                }
            }
            else if (isFunction(node)) {
                // If it is a function declaration, it could be shadowing an import
                // Add its name to the scope so it won't get replaced
                if (node.type === 'FunctionDeclaration') {
                    const parentFunction = findParentFunction(parentStack);
                    if (parentFunction) {
                        setScope(parentFunction, node.id.name);
                    }
                }
                // walk function expressions and add its arguments to known identifiers
                // so that we don't prefix them
                node.params.forEach((p) => walk$1(p.type === 'AssignmentPattern' ? p.left : p, {
                    enter(child, parent) {
                        if (child.type !== 'Identifier')
                            return;
                        // do not record as scope variable if is a destructuring keyword
                        if (isStaticPropertyKey(child, parent))
                            return;
                        // do not record if this is a default value
                        // assignment of a destructuring variable
                        if (((parent === null || parent === void 0 ? void 0 : parent.type) === 'AssignmentPattern' &&
                            (parent === null || parent === void 0 ? void 0 : parent.right) === child) ||
                            ((parent === null || parent === void 0 ? void 0 : parent.type) === 'TemplateLiteral' &&
                                (parent === null || parent === void 0 ? void 0 : parent.expressions.includes(child)))) {
                            return;
                        }
                        setScope(node, child.name);
                    }
                }));
            }
            else if (node.type === 'Property' && parent.type === 'ObjectPattern') {
                node.inPattern = true;
            }
            else if (node.type === 'VariableDeclarator') {
                const parentFunction = findParentFunction(parentStack);
                if (parentFunction) {
                    if (node.id.type === 'ObjectPattern') {
                        node.id.properties.forEach((property) => {
                            if (property.type === 'RestElement') {
                                setScope(parentFunction, property.argument.name);
                            }
                            else {
                                setScope(parentFunction, property.value.name);
                            }
                        });
                    }
                    else if (node.id.type === 'ArrayPattern') {
                        node.id.elements.forEach((element) => {
                            setScope(parentFunction, element.name);
                        });
                    }
                    else {
                        setScope(parentFunction, node.id.name);
                    }
                }
            }
        },
        leave(node, parent) {
            parent && parentStack.pop();
            const scopeIds = scopeMap.get(node);
            if (scopeIds) {
                scopeIds.forEach((id) => {
                    scope[id]--;
                    if (scope[id] === 0) {
                        delete scope[id];
                    }
                });
            }
        }
    });
}
function isRefIdentifier(id, parent, parentStack) {
    // declaration id
    if (parent.type === 'CatchClause' ||
        ((parent.type === 'VariableDeclarator' ||
            parent.type === 'ClassDeclaration') &&
            parent.id === id)) {
        return false;
    }
    if (isFunction(parent)) {
        // function declaration/expression id
        if (parent.id === id) {
            return false;
        }
        // params list
        if (parent.params.includes(id)) {
            return false;
        }
    }
    // class method name
    if (parent.type === 'MethodDefinition') {
        return false;
    }
    // property key
    // this also covers object destructuring pattern
    if (isStaticPropertyKey(id, parent) || parent.inPattern) {
        return false;
    }
    // non-assignment array destructuring pattern
    if (parent.type === 'ArrayPattern' &&
        !isInDestructuringAssignment(parent, parentStack)) {
        return false;
    }
    // member expression property
    if (parent.type === 'MemberExpression' &&
        parent.property === id &&
        !parent.computed) {
        return false;
    }
    if (parent.type === 'ExportSpecifier') {
        return false;
    }
    // is a special keyword but parsed as identifier
    if (id.name === 'arguments') {
        return false;
    }
    return true;
}
const isStaticProperty = (node) => node && node.type === 'Property' && !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
function isFunction(node) {
    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
}
function findParentFunction(parentStack) {
    for (let i = parentStack.length - 1; i >= 0; i--) {
        const node = parentStack[i];
        if (isFunction(node)) {
            return node;
        }
    }
}
function isInDestructuringAssignment(parent, parentStack) {
    if (parent &&
        (parent.type === 'Property' || parent.type === 'ArrayPattern')) {
        let i = parentStack.length;
        while (i--) {
            const p = parentStack[i];
            if (p.type === 'AssignmentExpression') {
                return true;
            }
            else if (p.type !== 'Property' && !p.type.endsWith('Pattern')) {
                break;
            }
        }
    }
    return false;
}

// Virtual modules should be prefixed with a null byte to avoid a
// false positive "missing source" warning. We also check for certain
// prefixes used for special handling in esbuildDepPlugin.
const virtualSourceRE = /^(\0|dep:|browser-external:)/;
async function injectSourcesContent(map, file, logger) {
    let sourceRoot;
    try {
        // The source root is undefined for virtual modules and permission errors.
        sourceRoot = await promises.realpath(path.resolve(path.dirname(file), map.sourceRoot || ''));
    }
    catch { }
    const missingSources = [];
    map.sourcesContent = await Promise.all(map.sources.map((sourcePath) => {
        if (sourcePath && !virtualSourceRE.test(sourcePath)) {
            sourcePath = decodeURI(sourcePath);
            if (sourceRoot) {
                sourcePath = path.resolve(sourceRoot, sourcePath);
            }
            return promises.readFile(sourcePath, 'utf-8').catch(() => {
                missingSources.push(sourcePath);
                return null;
            });
        }
        return null;
    }));
    // Use this command…
    //    DEBUG="vite:sourcemap" vite build
    // …to log the missing sources.
    if (missingSources.length) {
        logger.warnOnce(`Sourcemap for "${file}" points to missing source files`);
    }
}

function createDevHtmlTransformFn(server) {
    const [preHooks, postHooks] = resolveHtmlTransforms(server.config.plugins);
    return (url, html, originalUrl) => {
        return applyHtmlTransforms(html, [...preHooks, devHtmlHook, ...postHooks], {
            path: url,
            filename: getHtmlFilename(url, server),
            server,
            originalUrl
        });
    };
}
function getHtmlFilename(url, server) {
    if (url.startsWith(FS_PREFIX)) {
        return decodeURIComponent(fsPathFromId(url));
    }
    else {
        return decodeURIComponent(path.join(server.config.root, url.slice(1)));
    }
}
const startsWithSingleSlashRE = /^\/(?!\/)/;
const processNodeUrl = (node, s, config, htmlPath, originalUrl, moduleGraph) => {
    var _a;
    let url = ((_a = node.value) === null || _a === void 0 ? void 0 : _a.content) || '';
    if (moduleGraph) {
        const mod = moduleGraph.urlToModuleMap.get(url);
        if (mod && mod.lastHMRTimestamp > 0) {
            url = injectQuery(url, `t=${mod.lastHMRTimestamp}`);
        }
    }
    if (startsWithSingleSlashRE.test(url)) {
        // prefix with base
        s.overwrite(node.value.loc.start.offset, node.value.loc.end.offset, `"${config.base + url.slice(1)}"`);
    }
    else if (url.startsWith('.') &&
        originalUrl &&
        originalUrl !== '/' &&
        htmlPath === '/index.html') {
        // #3230 if some request url (localhost:3000/a/b) return to fallback html, the relative assets
        // path will add `/a/` prefix, it will caused 404.
        // rewrite before `./index.js` -> `localhost:3000/a/index.js`.
        // rewrite after `../index.js` -> `localhost:3000/index.js`.
        s.overwrite(node.value.loc.start.offset, node.value.loc.end.offset, `"${path.posix.join(path.posix.relative(originalUrl, '/'), url.slice(1))}"`);
    }
};
const devHtmlHook = async (html, { path: htmlPath, server, originalUrl }) => {
    const { config, moduleGraph } = server;
    const base = config.base || '/';
    const s = new MagicString(html);
    let scriptModuleIndex = -1;
    const filePath = cleanUrl(htmlPath);
    await traverseHtml(html, htmlPath, (node) => {
        if (node.type !== 1 /* ELEMENT */) {
            return;
        }
        // script tags
        if (node.tag === 'script') {
            const { src, isModule } = getScriptInfo(node);
            if (isModule) {
                scriptModuleIndex++;
            }
            if (src) {
                processNodeUrl(src, s, config, htmlPath, originalUrl, moduleGraph);
            }
            else if (isModule) {
                const url = filePath.replace(normalizePath(config.root), '');
                const contents = node.children
                    .map((child) => child.content || '')
                    .join('');
                // add HTML Proxy to Map
                addToHTMLProxyCache(config, url, scriptModuleIndex, contents);
                // inline js module. convert to src="proxy"
                const modulePath = `${config.base + htmlPath.slice(1)}?html-proxy&index=${scriptModuleIndex}.js`;
                // invalidate the module so the newly cached contents will be served
                const module = server === null || server === void 0 ? void 0 : server.moduleGraph.getModuleById(modulePath);
                if (module) {
                    server === null || server === void 0 ? void 0 : server.moduleGraph.invalidateModule(module);
                }
                s.overwrite(node.loc.start.offset, node.loc.end.offset, `<script type="module" src="${modulePath}"></script>`);
            }
        }
        // elements with [href/src] attrs
        const assetAttrs = assetAttrsConfig[node.tag];
        if (assetAttrs) {
            for (const p of node.props) {
                if (p.type === 6 /* ATTRIBUTE */ &&
                    p.value &&
                    assetAttrs.includes(p.name)) {
                    processNodeUrl(p, s, config, htmlPath, originalUrl);
                }
            }
        }
    });
    html = s.toString();
    return {
        html,
        tags: [
            {
                tag: 'script',
                attrs: {
                    type: 'module',
                    src: path.posix.join(base, CLIENT_PUBLIC_PATH)
                },
                injectTo: 'head-prepend'
            }
        ]
    };
};

const _matchOptions = { matchBase: true };
function isFileServingAllowed(url, server) {
    if (!server.config.server.fs.strict)
        return true;
    const cleanedUrl = cleanUrl(url);
    const file = ensureLeadingSlash(normalizePath(cleanedUrl));
    if (server.config.server.fs.deny.some((i) => isMatch(file, i, _matchOptions)))
        return false;
    if (server.moduleGraph.safeModulesPath.has(file))
        return true;
    if (server.config.server.fs.allow.some((i) => file.startsWith(i + '/')))
        return true;
    return false;
}

function transformRequest(url, server, options = {}) {
    const cacheKey = (options.ssr ? 'ssr:' : options.html ? 'html:' : '') + url;
    let request = server._pendingRequests.get(cacheKey);
    if (!request) {
        request = doTransform(url, server, options);
        server._pendingRequests.set(cacheKey, request);
        const done = () => server._pendingRequests.delete(cacheKey);
        request.then(done, done);
    }
    return request;
}
async function doTransform(url, server, options) {
    var _a, _b;
    url = removeTimestampQuery(url);
    const { config, pluginContainer, moduleGraph, watcher } = server;
    const { root, logger } = config;
    const ssr = !!options.ssr;
    const module = await server.moduleGraph.getModuleByUrl(url, ssr);
    // check if we have a fresh cache
    const cached = module && (ssr ? module.ssrTransformResult : module.transformResult);
    if (cached) {
        return cached;
    }
    // resolve
    const id = ((_a = (await pluginContainer.resolveId(url, undefined, { ssr }))) === null || _a === void 0 ? void 0 : _a.id) || url;
    const file = cleanUrl(id);
    let code = null;
    let map = null;
    const loadResult = await pluginContainer.load(id, { ssr });
    if (loadResult == null) {
        // if this is an html request and there is no load result, skip ahead to
        // SPA fallback.
        if (options.html && !id.endsWith('.html')) {
            return null;
        }
        // try fallback loading it from fs as string
        // if the file is a binary, there should be a plugin that already loaded it
        // as string
        // only try the fallback if access is allowed, skip for out of root url
        // like /service-worker.js or /api/users
        if (options.ssr || isFileServingAllowed(file, server)) {
            try {
                code = await promises.readFile(file, 'utf-8');
            }
            catch (e) {
                if (e.code !== 'ENOENT') {
                    throw e;
                }
            }
        }
        if (code) {
            try {
                map = (_b = (convertSourceMap.fromSource(code) ||
                    convertSourceMap.fromMapFileSource(code, path.dirname(file)))) === null || _b === void 0 ? void 0 : _b.toObject();
            }
            catch (e) {
                logger.warn(`Failed to load source map for ${url}.`, {
                    timestamp: true
                });
            }
        }
    }
    else {
        if (isObject(loadResult)) {
            code = loadResult.code;
            map = loadResult.map;
        }
        else {
            code = loadResult;
        }
    }
    if (code == null) {
        if (checkPublicFile(url, config)) {
            throw new Error(`Failed to load url ${url} (resolved id: ${id}). ` +
                `This file is in /public and will be copied as-is during build without ` +
                `going through the plugin transforms, and therefore should not be ` +
                `imported from source code. It can only be referenced via HTML tags.`);
        }
        else {
            return null;
        }
    }
    // ensure module in graph after successful load
    const mod = await moduleGraph.ensureEntryFromUrl(url, ssr);
    ensureWatchedFile(watcher, mod.file, root);
    const transformResult = await pluginContainer.transform(code, id, {
        inMap: map,
        ssr
    });
    if (transformResult == null ||
        (isObject(transformResult) && transformResult.code == null)) ;
    else {
        code = transformResult.code;
        map = transformResult.map;
    }
    if (map && mod.file) {
        map = (typeof map === 'string' ? JSON.parse(map) : map);
        if (map.mappings && !map.sourcesContent) {
            await injectSourcesContent(map, mod.file, logger);
        }
    }
    if (ssr) {
        return (mod.ssrTransformResult = await ssrTransform(code, map, url));
    }
    else {
        return (mod.transformResult = {
            code,
            map,
            etag: getEtag(code, { weak: true })
        });
    }
}

class ModuleNode {
    constructor(url) {
        /**
         * Resolved file system path + query
         */
        this.id = null;
        this.file = null;
        this.importers = new Set();
        this.importedModules = new Set();
        this.acceptedHmrDeps = new Set();
        this.isSelfAccepting = false;
        this.transformResult = null;
        this.ssrTransformResult = null;
        this.ssrModule = null;
        this.lastHMRTimestamp = 0;
        this.url = url;
        this.type = isDirectCSSRequest(url) ? 'css' : 'js';
    }
}
function invalidateSSRModule(mod, seen) {
    if (seen.has(mod)) {
        return;
    }
    seen.add(mod);
    mod.ssrModule = null;
    mod.importers.forEach((importer) => invalidateSSRModule(importer, seen));
}
class ModuleGraph {
    constructor(resolveId) {
        this.resolveId = resolveId;
        this.urlToModuleMap = new Map();
        this.idToModuleMap = new Map();
        // a single file may corresponds to multiple modules with different queries
        this.fileToModulesMap = new Map();
        this.safeModulesPath = new Set();
    }
    async getModuleByUrl(rawUrl, ssr) {
        const [url] = await this.resolveUrl(rawUrl, ssr);
        return this.urlToModuleMap.get(url);
    }
    getModuleById(id) {
        return this.idToModuleMap.get(removeTimestampQuery(id));
    }
    getModulesByFile(file) {
        return this.fileToModulesMap.get(file);
    }
    onFileChange(file) {
        const mods = this.getModulesByFile(file);
        if (mods) {
            const seen = new Set();
            mods.forEach((mod) => {
                this.invalidateModule(mod, seen);
            });
        }
    }
    invalidateModule(mod, seen = new Set()) {
        mod.info = undefined;
        mod.transformResult = null;
        mod.ssrTransformResult = null;
        invalidateSSRModule(mod, seen);
    }
    invalidateAll() {
        const seen = new Set();
        this.idToModuleMap.forEach((mod) => {
            this.invalidateModule(mod, seen);
        });
    }
    /**
     * Update the module graph based on a module's updated imports information
     * If there are dependencies that no longer have any importers, they are
     * returned as a Set.
     */
    async updateModuleInfo(mod, importedModules, acceptedModules, isSelfAccepting, ssr) {
        mod.isSelfAccepting = isSelfAccepting;
        const prevImports = mod.importedModules;
        const nextImports = (mod.importedModules = new Set());
        let noLongerImported;
        // update import graph
        for (const imported of importedModules) {
            const dep = typeof imported === 'string'
                ? await this.ensureEntryFromUrl(imported, ssr)
                : imported;
            dep.importers.add(mod);
            nextImports.add(dep);
        }
        // remove the importer from deps that were imported but no longer are.
        prevImports.forEach((dep) => {
            if (!nextImports.has(dep)) {
                dep.importers.delete(mod);
                if (!dep.importers.size) {
                    (noLongerImported || (noLongerImported = new Set())).add(dep);
                }
            }
        });
        // update accepted hmr deps
        const deps = (mod.acceptedHmrDeps = new Set());
        for (const accepted of acceptedModules) {
            const dep = typeof accepted === 'string'
                ? await this.ensureEntryFromUrl(accepted, ssr)
                : accepted;
            deps.add(dep);
        }
        return noLongerImported;
    }
    async ensureEntryFromUrl(rawUrl, ssr) {
        const [url, resolvedId, meta] = await this.resolveUrl(rawUrl, ssr);
        let mod = this.urlToModuleMap.get(url);
        if (!mod) {
            mod = new ModuleNode(url);
            if (meta)
                mod.meta = meta;
            this.urlToModuleMap.set(url, mod);
            mod.id = resolvedId;
            this.idToModuleMap.set(resolvedId, mod);
            const file = (mod.file = cleanUrl(resolvedId));
            let fileMappedModules = this.fileToModulesMap.get(file);
            if (!fileMappedModules) {
                fileMappedModules = new Set();
                this.fileToModulesMap.set(file, fileMappedModules);
            }
            fileMappedModules.add(mod);
        }
        return mod;
    }
    // some deps, like a css file referenced via @import, don't have its own
    // url because they are inlined into the main css import. But they still
    // need to be represented in the module graph so that they can trigger
    // hmr in the importing css file.
    createFileOnlyEntry(file) {
        file = normalizePath(file);
        let fileMappedModules = this.fileToModulesMap.get(file);
        if (!fileMappedModules) {
            fileMappedModules = new Set();
            this.fileToModulesMap.set(file, fileMappedModules);
        }
        const url = `${FS_PREFIX}${file}`;
        for (const m of fileMappedModules) {
            if (m.url === url || m.id === file) {
                return m;
            }
        }
        const mod = new ModuleNode(url);
        mod.file = file;
        fileMappedModules.add(mod);
        return mod;
    }
    // for incoming urls, it is important to:
    // 1. remove the HMR timestamp query (?t=xxxx)
    // 2. resolve its extension so that urls with or without extension all map to
    // the same module
    async resolveUrl(url, ssr) {
        url = removeImportQuery(removeTimestampQuery(url));
        const resolved = await this.resolveId(url, !!ssr);
        const resolvedId = (resolved === null || resolved === void 0 ? void 0 : resolved.id) || url;
        const ext = extname(cleanUrl(resolvedId));
        const { pathname, search, hash } = parse(url);
        if (ext && !pathname.endsWith(ext)) {
            url = pathname + ext + (search || '') + (hash || '');
        }
        return [url, resolvedId, resolved === null || resolved === void 0 ? void 0 : resolved.meta];
    }
}

const debugHmr$1 = createDebugger('vite:hmr');
normalizePath(CLIENT_DIR);
function handlePrunedModules(mods, { ws }) {
    // update the disposed modules' hmr timestamp
    // since if it's re-imported, it should re-apply side effects
    // and without the timestamp the browser will not re-import it!
    const t = Date.now();
    mods.forEach((mod) => {
        mod.lastHMRTimestamp = t;
        debugHmr$1(`[dispose] ${p.dim(mod.file)}`);
    });
    ws.send({
        type: 'prune',
        paths: [...mods].map((m) => m.url)
    });
}
/**
 * Lex import.meta.hot.accept() for accepted deps.
 * Since hot.accept() can only accept string literals or array of string
 * literals, we don't really need a heavy @babel/parse call on the entire source.
 *
 * @returns selfAccepts
 */
function lexAcceptedHmrDeps(code, start, urls) {
    let state = 0 /* inCall */;
    // the state can only be 2 levels deep so no need for a stack
    let prevState = 0 /* inCall */;
    let currentDep = '';
    function addDep(index) {
        urls.add({
            url: currentDep,
            start: index - currentDep.length - 1,
            end: index + 1
        });
        currentDep = '';
    }
    for (let i = start; i < code.length; i++) {
        const char = code.charAt(i);
        switch (state) {
            case 0 /* inCall */:
            case 4 /* inArray */:
                if (char === `'`) {
                    prevState = state;
                    state = 1 /* inSingleQuoteString */;
                }
                else if (char === `"`) {
                    prevState = state;
                    state = 2 /* inDoubleQuoteString */;
                }
                else if (char === '`') {
                    prevState = state;
                    state = 3 /* inTemplateString */;
                }
                else if (/\s/.test(char)) {
                    continue;
                }
                else {
                    if (state === 0 /* inCall */) {
                        if (char === `[`) {
                            state = 4 /* inArray */;
                        }
                        else {
                            // reaching here means the first arg is neither a string literal
                            // nor an Array literal (direct callback) or there is no arg
                            // in both case this indicates a self-accepting module
                            return true; // done
                        }
                    }
                    else if (state === 4 /* inArray */) {
                        if (char === `]`) {
                            return false; // done
                        }
                        else if (char === ',') {
                            continue;
                        }
                        else {
                            error(i);
                        }
                    }
                }
                break;
            case 1 /* inSingleQuoteString */:
                if (char === `'`) {
                    addDep(i);
                    if (prevState === 0 /* inCall */) {
                        // accept('foo', ...)
                        return false;
                    }
                    else {
                        state = prevState;
                    }
                }
                else {
                    currentDep += char;
                }
                break;
            case 2 /* inDoubleQuoteString */:
                if (char === `"`) {
                    addDep(i);
                    if (prevState === 0 /* inCall */) {
                        // accept('foo', ...)
                        return false;
                    }
                    else {
                        state = prevState;
                    }
                }
                else {
                    currentDep += char;
                }
                break;
            case 3 /* inTemplateString */:
                if (char === '`') {
                    addDep(i);
                    if (prevState === 0 /* inCall */) {
                        // accept('foo', ...)
                        return false;
                    }
                    else {
                        state = prevState;
                    }
                }
                else if (char === '$' && code.charAt(i + 1) === '{') {
                    error(i);
                }
                else {
                    currentDep += char;
                }
                break;
            default:
                throw new Error('unknown import.meta.hot lexer state');
        }
    }
    return false;
}
function error(pos) {
    const err = new Error(`import.meta.accept() can only accept string literals or an ` +
        `Array of string literals.`);
    err.pos = pos;
    throw err;
}

try {
    new Function('throw new Error(1)')();
}
catch (e) {
    // in Node 12, stack traces account for the function wrapper.
    // in Node 13 and later, the function wrapper adds two lines,
    // which must be subtracted to generate a valid mapping
    /:(\d+):\d+\)$/.exec(e.stack.split('\n')[1]);
}

/**
 * The amount to wait for requests to register newly found dependencies before triggering
 * a re-bundle + page reload
 */
const debounceMs = 100;
function createMissingImporterRegisterFn(server, optimizeDeps) {
    const { logger } = server.config;
    let knownOptimized = server._optimizeDepsMetadata.optimized;
    let currentMissing = {};
    let handle;
    let pendingResolve = null;
    async function rerun(ssr) {
        const newDeps = currentMissing;
        currentMissing = {};
        logger.info(p.yellow(`new dependencies found: ${Object.keys(newDeps).join(', ')}, updating...`), {
            timestamp: true
        });
        for (const id in knownOptimized) {
            newDeps[id] = knownOptimized[id].src;
        }
        try {
            // Nullify previous metadata so that the resolver won't
            // resolve to optimized files during the optimizer re-run
            server._isRunningOptimizer = true;
            server._optimizeDepsMetadata = null;
            const newData = (server._optimizeDepsMetadata = await optimizeDeps(server.config, true, false, newDeps, ssr));
            knownOptimized = newData.optimized;
            // update ssr externals
            server._ssrExternals = resolveSSRExternal(server.config, Object.keys(knownOptimized));
            logger.info(p.greenBright(`✨ dependencies updated, reloading page...`), { timestamp: true });
        }
        catch (e) {
            logger.error(p.red(`error while updating dependencies:\n${e.stack}`), { timestamp: true, error: e });
        }
        finally {
            server._isRunningOptimizer = false;
            if (!handle) {
                // No other rerun() pending so resolve and let pending requests proceed
                pendingResolve && pendingResolve();
                server._pendingReload = pendingResolve = null;
            }
        }
        // Cached transform results have stale imports (resolved to
        // old locations) so they need to be invalidated before the page is
        // reloaded.
        server.moduleGraph.invalidateAll();
        server.ws.send({
            type: 'full-reload',
            path: '*'
        });
    }
    return function registerMissingImport(id, resolved, ssr) {
        if (!knownOptimized[id]) {
            currentMissing[id] = resolved;
            if (handle)
                clearTimeout(handle);
            handle = setTimeout(() => {
                handle = undefined;
                rerun(ssr);
            }, debounceMs);
            if (!server._pendingReload) {
                server._pendingReload = new Promise((r) => {
                    pendingResolve = r;
                });
            }
        }
    };
}

/**
 * https://github.com/rollup/plugins/blob/master/packages/json/src/index.js
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/rollup/plugins/blob/master/LICENSE
 */
// Custom json filter for vite
const jsonExtRE = /\.json($|\?)(?!commonjs-(proxy|external))/;
function jsonPlugin(options = {}, isBuild) {
    return {
        name: 'vite:json',
        transform(json, id) {
            if (!jsonExtRE.test(id))
                return null;
            if (SPECIAL_QUERY_RE.test(id))
                return null;
            try {
                if (options.stringify) {
                    if (isBuild) {
                        return {
                            // during build, parse then double-stringify to remove all
                            // unnecessary whitespaces to reduce bundle size.
                            code: `export default JSON.parse(${JSON.stringify(JSON.stringify(JSON.parse(json)))})`,
                            map: { mappings: '' }
                        };
                    }
                    else {
                        return `export default JSON.parse(${JSON.stringify(json)})`;
                    }
                }
                const parsed = JSON.parse(json);
                return {
                    code: dataToEsm(parsed, {
                        preferConst: true,
                        namedExports: options.namedExports
                    }),
                    map: { mappings: '' }
                };
            }
            catch (e) {
                const errorMessageList = /[\d]+/.exec(e.message);
                const position = errorMessageList && parseInt(errorMessageList[0], 10);
                const msg = position
                    ? `, invalid JSON syntax found at line ${position}`
                    : `.`;
                this.error(`Failed to parse JSON file` + msg, e.idx);
            }
        }
    };
}

const clientDir = normalizePath(CLIENT_DIR);
const skipRE = /\.(map|json)$/;
const canSkip = (id) => skipRE.test(id) || isDirectCSSRequest(id);
function isExplicitImportRequired(url) {
    return !isJSRequest(cleanUrl(url)) && !isCSSRequest(url);
}
function markExplicitImport(url) {
    if (isExplicitImportRequired(url)) {
        return injectQuery(url, 'import');
    }
    return url;
}
/**
 * Server-only plugin that lexes, resolves, rewrites and analyzes url imports.
 *
 * - Imports are resolved to ensure they exist on disk
 *
 * - Lexes HMR accept calls and updates import relationships in the module graph
 *
 * - Bare module imports are resolved (by @rollup-plugin/node-resolve) to
 * absolute file paths, e.g.
 *
 *     ```js
 *     import 'foo'
 *     ```
 *     is rewritten to
 *     ```js
 *     import '/@fs//project/node_modules/foo/dist/foo.js'
 *     ```
 *
 * - CSS imports are appended with `.js` since both the js module and the actual
 * css (referenced via <link>) may go through the transform pipeline:
 *
 *     ```js
 *     import './style.css'
 *     ```
 *     is rewritten to
 *     ```js
 *     import './style.css.js'
 *     ```
 */
function importAnalysisPlugin(config) {
    const { root, base } = config;
    const clientPublicPath = path.posix.join(base, CLIENT_PUBLIC_PATH);
    let server;
    return {
        name: 'vite:import-analysis',
        configureServer(_server) {
            server = _server;
        },
        async transform(source, importer, options) {
            const ssr = (options === null || options === void 0 ? void 0 : options.ssr) === true;
            const prettyImporter = prettifyUrl(importer, root);
            if (canSkip(importer)) {
                return null;
            }
            performance.now();
            await init;
            let imports = [];
            // strip UTF-8 BOM
            if (source.charCodeAt(0) === 0xfeff) {
                source = source.slice(1);
            }
            try {
                imports = parse$2(source)[0];
            }
            catch (e) {
                const isVue = importer.endsWith('.vue');
                const maybeJSX = !isVue && isJSRequest(importer);
                const msg = isVue
                    ? `Install @vitejs/plugin-vue to handle .vue files.`
                    : maybeJSX
                        ? `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.`
                        : `You may need to install appropriate plugins to handle the ${path.extname(importer)} file format.`;
                this.error(`Failed to parse source for import analysis because the content ` +
                    `contains invalid JS syntax. ` +
                    msg, e.idx);
            }
            if (!imports.length) {
                return source;
            }
            let hasHMR = false;
            let isSelfAccepting = false;
            let hasEnv = false;
            let needQueryInjectHelper = false;
            let s;
            const str = () => s || (s = new MagicString(source));
            // vite-only server context
            const { moduleGraph } = server;
            // since we are already in the transform phase of the importer, it must
            // have been loaded so its entry is guaranteed in the module graph.
            const importerModule = moduleGraph.getModuleById(importer);
            const importedUrls = new Set();
            const staticImportedUrls = new Set();
            const acceptedUrls = new Set();
            const toAbsoluteUrl = (url) => path.posix.resolve(path.posix.dirname(importerModule.url), url);
            const normalizeUrl = async (url, pos) => {
                var _a;
                if (base !== '/' && url.startsWith(base)) {
                    url = url.replace(base, '/');
                }
                let importerFile = importer;
                if (moduleListContains((_a = config.optimizeDeps) === null || _a === void 0 ? void 0 : _a.exclude, url) &&
                    server._optimizeDepsMetadata) {
                    // if the dependency encountered in the optimized file was excluded from the optimization
                    // the dependency needs to be resolved starting from the original source location of the optimized file
                    // because starting from node_modules/.vite will not find the dependency if it was not hoisted
                    // (that is, if it is under node_modules directory in the package source of the optimized file)
                    for (const optimizedModule of Object.values(server._optimizeDepsMetadata.optimized)) {
                        if (optimizedModule.file === importerModule.file) {
                            importerFile = optimizedModule.src;
                        }
                    }
                }
                const resolved = await this.resolve(url, importerFile);
                if (!resolved) {
                    this.error(`Failed to resolve import "${url}" from "${path.relative(process.cwd(), importerFile)}". Does the file exist?`, pos);
                }
                const isRelative = url.startsWith('.');
                const isSelfImport = !isRelative && cleanUrl(url) === cleanUrl(importer);
                // normalize all imports into resolved URLs
                // e.g. `import 'foo'` -> `import '/@fs/.../node_modules/foo/index.js`
                if (resolved.id.startsWith(root + '/')) {
                    // in root: infer short absolute path from root
                    url = resolved.id.slice(root.length);
                }
                else if (fs.existsSync(cleanUrl(resolved.id))) {
                    // exists but out of root: rewrite to absolute /@fs/ paths
                    url = path.posix.join(FS_PREFIX + resolved.id);
                }
                else {
                    url = resolved.id;
                }
                if (isExternalUrl(url)) {
                    return [url, url];
                }
                // if the resolved id is not a valid browser import specifier,
                // prefix it to make it valid. We will strip this before feeding it
                // back into the transform pipeline
                if (!url.startsWith('.') && !url.startsWith('/')) {
                    url =
                        VALID_ID_PREFIX + resolved.id.replace('\0', NULL_BYTE_PLACEHOLDER);
                }
                // make the URL browser-valid if not SSR
                if (!ssr) {
                    // mark non-js/css imports with `?import`
                    url = markExplicitImport(url);
                    // for relative js/css imports, or self-module virtual imports
                    // (e.g. vue blocks), inherit importer's version query
                    // do not do this for unknown type imports, otherwise the appended
                    // query can break 3rd party plugin's extension checks.
                    if ((isRelative || isSelfImport) && !/[\?&]import=?\b/.test(url)) {
                        const versionMatch = importer.match(DEP_VERSION_RE);
                        if (versionMatch) {
                            url = injectQuery(url, versionMatch[1]);
                        }
                    }
                    // check if the dep has been hmr updated. If yes, we need to attach
                    // its last updated timestamp to force the browser to fetch the most
                    // up-to-date version of this module.
                    try {
                        const depModule = await moduleGraph.ensureEntryFromUrl(url, ssr);
                        if (depModule.lastHMRTimestamp > 0) {
                            url = injectQuery(url, `t=${depModule.lastHMRTimestamp}`);
                        }
                    }
                    catch (e) {
                        // it's possible that the dep fails to resolve (non-existent import)
                        // attach location to the missing import
                        e.pos = pos;
                        throw e;
                    }
                    // prepend base (dev base is guaranteed to have ending slash)
                    url = base + url.replace(/^\//, '');
                }
                return [url, resolved.id];
            };
            for (let index = 0; index < imports.length; index++) {
                const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex, 
                // #2083 User may use escape path,
                // so use imports[index].n to get the unescaped string
                // @ts-ignore
                n: specifier } = imports[index];
                const rawUrl = source.slice(start, end);
                // check import.meta usage
                if (rawUrl === 'import.meta') {
                    const prop = source.slice(end, end + 4);
                    if (prop === '.hot') {
                        hasHMR = true;
                        if (source.slice(end + 4, end + 11) === '.accept') {
                            // further analyze accepted modules
                            if (lexAcceptedHmrDeps(source, source.indexOf('(', end + 11) + 1, acceptedUrls)) {
                                isSelfAccepting = true;
                            }
                        }
                    }
                    else if (prop === '.env') {
                        hasEnv = true;
                    }
                    else if (prop === '.glo' && source[end + 4] === 'b') {
                        // transform import.meta.glob()
                        // e.g. `import.meta.glob('glob:./dir/*.js')`
                        const { imports, importsString, exp, endIndex, base, pattern, isEager } = await transformImportGlob(source, start, importer, index, root, normalizeUrl);
                        str().prepend(importsString);
                        str().overwrite(expStart, endIndex, exp);
                        imports.forEach((url) => {
                            url = url.replace(base, '/');
                            importedUrls.add(url);
                            if (isEager)
                                staticImportedUrls.add(url);
                        });
                        if (!(importerModule.file in server._globImporters)) {
                            server._globImporters[importerModule.file] = {
                                module: importerModule,
                                importGlobs: []
                            };
                        }
                        server._globImporters[importerModule.file].importGlobs.push({
                            base,
                            pattern
                        });
                    }
                    continue;
                }
                const isDynamicImport = dynamicIndex >= 0;
                // static import or valid string in dynamic import
                // If resolvable, let's resolve it
                if (specifier) {
                    // skip external / data uri
                    // BROWSER VITE patch: support URL resolve in build mode
                    if ( /*isExternalUrl(specifier) || */isDataUrl(specifier)) {
                        continue;
                    }
                    // skip ssr external
                    if (ssr) {
                        if (server._ssrExternals &&
                            shouldExternalizeForSSR(specifier, server._ssrExternals)) {
                            continue;
                        }
                        if (isBuiltin(specifier)) {
                            continue;
                        }
                    }
                    // skip client
                    if (specifier === clientPublicPath) {
                        continue;
                    }
                    // warn imports to non-asset /public files
                    if (specifier.startsWith('/') &&
                        !config.assetsInclude(cleanUrl(specifier)) &&
                        !specifier.endsWith('.json') &&
                        checkPublicFile(specifier, config)) {
                        throw new Error(`Cannot import non-asset file ${specifier} which is inside /public.` +
                            `JS/CSS files inside /public are copied as-is on build and ` +
                            `can only be referenced via <script src> or <link href> in html.`);
                    }
                    // normalize
                    const [normalizedUrl, resolvedId] = await normalizeUrl(specifier, start);
                    let url = normalizedUrl;
                    // record as safe modules
                    server === null || server === void 0 ? void 0 : server.moduleGraph.safeModulesPath.add(cleanUrl(url).slice(4 /* '/@fs'.length */));
                    // rewrite
                    if (url !== specifier) {
                        // for optimized cjs deps, support named imports by rewriting named
                        // imports to const assignments.
                        if (resolvedId.endsWith(`&es-interop`)) {
                            url = url.slice(0, -11);
                            if (isDynamicImport) {
                                // rewrite `import('package')` to expose the default directly
                                str().overwrite(dynamicIndex, end + 1, `import('${url}').then(m => m.default && m.default.__esModule ? m.default : ({ ...m.default, default: m.default }))`);
                            }
                            else {
                                const exp = source.slice(expStart, expEnd);
                                const rewritten = transformCjsImport(exp, url, rawUrl, index);
                                if (rewritten) {
                                    str().overwrite(expStart, expEnd, rewritten);
                                }
                                else {
                                    // #1439 export * from '...'
                                    str().overwrite(start, end, url);
                                }
                            }
                        }
                        else {
                            str().overwrite(start, end, isDynamicImport ? `'${url}'` : url);
                        }
                    }
                    // record for HMR import chain analysis
                    // make sure to normalize away base
                    const urlWithoutBase = url.replace(base, '/');
                    importedUrls.add(urlWithoutBase);
                    if (!isDynamicImport) {
                        // for pre-transforming
                        staticImportedUrls.add(urlWithoutBase);
                    }
                }
                else if (!importer.startsWith(clientDir) && !ssr) {
                    // check @vite-ignore which suppresses dynamic import warning
                    const hasViteIgnore = /\/\*\s*@vite-ignore\s*\*\//.test(rawUrl);
                    const url = rawUrl
                        .replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '')
                        .trim();
                    if (!hasViteIgnore && !isSupportedDynamicImport(url)) {
                        this.warn(`\n` +
                            p.cyan(importerModule.file) +
                            `\n` +
                            generateCodeFrame(source, start) +
                            `\nThe above dynamic import cannot be analyzed by vite.\n` +
                            `See ${p.blue(`https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`)} ` +
                            `for supported dynamic import formats. ` +
                            `If this is intended to be left as-is, you can use the ` +
                            `/* @vite-ignore */ comment inside the import() call to suppress this warning.\n`);
                    }
                    if (!/^('.*'|".*"|`.*`)$/.test(url) ||
                        isExplicitImportRequired(url.slice(1, -1))) {
                        needQueryInjectHelper = true;
                        str().overwrite(start, end, `__vite__injectQuery(${url}, 'import')`);
                    }
                }
            }
            if (hasEnv) {
                // inject import.meta.env
                let env = `import.meta.env = ${JSON.stringify({
                    ...config.env,
                    SSR: !!ssr
                })};`;
                // account for user env defines
                for (const key in config.define) {
                    if (key.startsWith(`import.meta.env.`)) {
                        const val = config.define[key];
                        env += `${key} = ${typeof val === 'string' ? val : JSON.stringify(val)};`;
                    }
                }
                str().prepend(env);
            }
            if (hasHMR && !ssr) {
                debugHmr$1(`${isSelfAccepting
                    ? `[self-accepts]`
                    : acceptedUrls.size
                        ? `[accepts-deps]`
                        : `[detected api usage]`} ${prettyImporter}`);
                // inject hot context
                str().prepend(`import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";` +
                    `import.meta.hot = __vite__createHotContext(${JSON.stringify(importerModule.url)});`);
            }
            if (needQueryInjectHelper) {
                str().prepend(`import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`);
            }
            // normalize and rewrite accepted urls
            const normalizedAcceptedUrls = new Set();
            for (const { url, start, end } of acceptedUrls) {
                const [normalized] = await moduleGraph.resolveUrl(toAbsoluteUrl(markExplicitImport(url)), ssr);
                normalizedAcceptedUrls.add(normalized);
                str().overwrite(start, end, JSON.stringify(normalized));
            }
            // update the module graph for HMR analysis.
            // node CSS imports does its own graph update in the css plugin so we
            // only handle js graph updates here.
            if (!isCSSRequest(importer)) {
                // attached by pluginContainer.addWatchFile
                const pluginImports = this._addedImports;
                if (pluginImports) {
                    (await Promise.all([...pluginImports].map((id) => normalizeUrl(id, 0)))).forEach(([url]) => importedUrls.add(url));
                }
                // HMR transforms are no-ops in SSR, so an `accept` call will
                // never be injected. Avoid updating the `isSelfAccepting`
                // property for our module node in that case.
                if (ssr && importerModule.isSelfAccepting) {
                    isSelfAccepting = true;
                }
                const prunedImports = await moduleGraph.updateModuleInfo(importerModule, importedUrls, normalizedAcceptedUrls, isSelfAccepting, ssr);
                if (hasHMR && prunedImports) {
                    handlePrunedModules(prunedImports, server);
                }
            }
            // pre-transform known direct imports
            if (staticImportedUrls.size) {
                staticImportedUrls.forEach((url) => {
                    transformRequest(unwrapId(removeImportQuery(url)), server, { ssr });
                });
            }
            if (s) {
                return s.toString();
            }
            else {
                return source;
            }
        }
    };
}
/**
 * https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations
 * This is probably less accurate but is much cheaper than a full AST parse.
 */
function isSupportedDynamicImport(url) {
    url = url.trim().slice(1, -1);
    // must be relative
    if (!url.startsWith('./') && !url.startsWith('../')) {
        return false;
    }
    // must have extension
    if (!path.extname(url)) {
        return false;
    }
    // must be more specific if importing from same dir
    if (url.startsWith('./${') && url.indexOf('/') === url.lastIndexOf('/')) {
        return false;
    }
    return true;
}
/**
 * Detect import statements to a known optimized CJS dependency and provide
 * ES named imports interop. We do this by rewriting named imports to a variable
 * assignment to the corresponding property on the `module.exports` of the cjs
 * module. Note this doesn't support dynamic re-assignments from within the cjs
 * module.
 *
 * Note that es-module-lexer treats `export * from '...'` as an import as well,
 * so, we may encounter ExportAllDeclaration here, in which case `undefined`
 * will be returned.
 *
 * Credits \@csr632 via #837
 */
function transformCjsImport(importExp, url, rawUrl, importIndex) {
    const node = parse$3(importExp, {
        ecmaVersion: 'latest',
        sourceType: 'module'
    }).body[0];
    if (node.type === 'ImportDeclaration' ||
        node.type === 'ExportNamedDeclaration') {
        if (!node.specifiers.length) {
            return `import "${url}"`;
        }
        const importNames = [];
        const exportNames = [];
        let defaultExports = '';
        for (const spec of node.specifiers) {
            if (spec.type === 'ImportSpecifier' &&
                spec.imported.type === 'Identifier') {
                const importedName = spec.imported.name;
                const localName = spec.local.name;
                importNames.push({ importedName, localName });
            }
            else if (spec.type === 'ImportDefaultSpecifier') {
                importNames.push({
                    importedName: 'default',
                    localName: spec.local.name
                });
            }
            else if (spec.type === 'ImportNamespaceSpecifier') {
                importNames.push({ importedName: '*', localName: spec.local.name });
            }
            else if (spec.type === 'ExportSpecifier' &&
                spec.exported.type === 'Identifier') {
                // for ExportSpecifier, local name is same as imported name
                const importedName = spec.local.name;
                // we want to specify exported name as variable and re-export it
                const exportedName = spec.exported.name;
                if (exportedName === 'default') {
                    defaultExports = makeLegalIdentifier(`__vite__cjsExportDefault_${importIndex}`);
                    importNames.push({ importedName, localName: defaultExports });
                }
                else {
                    importNames.push({ importedName, localName: exportedName });
                    exportNames.push(exportedName);
                }
            }
        }
        // If there is multiple import for same id in one file,
        // importIndex will prevent the cjsModuleName to be duplicate
        const cjsModuleName = makeLegalIdentifier(`__vite__cjsImport${importIndex}_${rawUrl}`);
        const lines = [`import ${cjsModuleName} from "${url}"`];
        importNames.forEach(({ importedName, localName }) => {
            if (importedName === '*') {
                lines.push(`const ${localName} = ${cjsModuleName}`);
            }
            else if (importedName === 'default') {
                lines.push(`const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`);
            }
            else {
                lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`);
            }
        });
        if (defaultExports) {
            lines.push(`export default ${defaultExports}`);
        }
        if (exportNames.length) {
            lines.push(`export { ${exportNames.join(', ')} }`);
        }
        return lines.join('; ');
    }
}

// ids in transform are normalized to unix style
const normalizedClientEntry = normalizePath(CLIENT_ENTRY);
const normalizedEnvEntry = normalizePath(ENV_ENTRY);
/**
 * some values used by the client needs to be dynamically injected by the server
 * @server-only
 */
function clientInjectionsPlugin(config) {
    return {
        name: 'vite:client-inject',
        transform(code, id) {
            if (id === normalizedClientEntry || id === normalizedEnvEntry) {
                let options = config.server.hmr;
                options = options && typeof options !== 'boolean' ? options : {};
                const host = options.host || null;
                const protocol = options.protocol || null;
                const timeout = options.timeout || 30000;
                const overlay = options.overlay !== false;
                let port;
                if (isObject(config.server.hmr)) {
                    port = config.server.hmr.clientPort || config.server.hmr.port;
                }
                if (config.server.middlewareMode) {
                    port = String(port || 24678);
                }
                else {
                    port = String(port || options.port || config.server.port);
                }
                let hmrBase = config.base;
                if (options.path) {
                    hmrBase = path.posix.join(hmrBase, options.path);
                }
                if (hmrBase !== '/') {
                    port = path.posix.normalize(`${port}${hmrBase}`);
                }
                return code
                    .replace(`__MODE__`, JSON.stringify(config.mode))
                    .replace(`__BASE__`, JSON.stringify(config.base))
                    .replace(`__DEFINES__`, serializeDefine(config.define || {}))
                    .replace(`__HMR_PROTOCOL__`, JSON.stringify(protocol))
                    .replace(`__HMR_HOSTNAME__`, JSON.stringify(host))
                    .replace(`__HMR_PORT__`, JSON.stringify(port))
                    .replace(`__HMR_TIMEOUT__`, JSON.stringify(timeout))
                    .replace(`__HMR_ENABLE_OVERLAY__`, JSON.stringify(overlay));
            }
            else if (code.includes('process.env.NODE_ENV')) {
                // replace process.env.NODE_ENV
                return code.replace(/\bprocess\.env\.NODE_ENV\b/g, JSON.stringify(config.mode));
            }
        }
    };
}
function serializeDefine(define) {
    let res = `{`;
    for (const key in define) {
        const val = define[key];
        res += `${JSON.stringify(key)}: ${typeof val === 'string' ? `(${val})` : JSON.stringify(val)}, `;
    }
    return res + `}`;
}

const wasmHelper = async (opts = {}, url) => {
    let result;
    if (url.startsWith('data:')) {
        // @ts-ignore
        const binaryString = atob(url.replace(/^data:.*?base64,/, ''));
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        // @ts-ignore
        result = await WebAssembly.instantiate(bytes, opts);
    }
    else {
        // https://github.com/mdn/webassembly-examples/issues/5
        // WebAssembly.instantiateStreaming requires the server to provide the
        // correct MIME type for .wasm files, which unfortunately doesn't work for
        // a lot of static file servers, so we just work around it by getting the
        // raw buffer.
        // @ts-ignore
        const response = await fetch(url);
        const contentType = response.headers.get('Content-Type') || '';
        if (
        // @ts-ignore
        'instantiateStreaming' in WebAssembly &&
            contentType.startsWith('application/wasm')) {
            // @ts-ignore
            result = await WebAssembly.instantiateStreaming(response, opts);
        }
        else {
            const buffer = await response.arrayBuffer();
            // @ts-ignore
            result = await WebAssembly.instantiate(buffer, opts);
        }
    }
    return result.instance.exports;
};
wasmHelper.toString();

function definePlugin(config) {
    const isBuild = config.command === 'build';
    const processNodeEnv = {
        'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || config.mode),
        'global.process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || config.mode),
        'globalThis.process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || config.mode)
    };
    const userDefine = {};
    for (const key in config.define) {
        const val = config.define[key];
        userDefine[key] = typeof val === 'string' ? val : JSON.stringify(val);
    }
    // during dev, import.meta properties are handled by importAnalysis plugin
    const importMetaKeys = {};
    if (isBuild) {
        const env = {
            ...config.env,
            SSR: !!config.build.ssr
        };
        for (const key in env) {
            importMetaKeys[`import.meta.env.${key}`] = JSON.stringify(env[key]);
        }
        Object.assign(importMetaKeys, {
            'import.meta.env.': `({}).`,
            'import.meta.env': JSON.stringify(config.env),
            'import.meta.hot': `false`
        });
    }
    function generatePattern(ssr) {
        var _a;
        const processEnv = {};
        if (!ssr || ((_a = config.ssr) === null || _a === void 0 ? void 0 : _a.target) === 'webworker') {
            Object.assign(processEnv, {
                'process.env.': `({}).`,
                'global.process.env.': `({}).`,
                'globalThis.process.env.': `({}).`
            });
        }
        const replacements = {
            ...processNodeEnv,
            ...userDefine,
            ...importMetaKeys,
            ...processEnv
        };
        const pattern = new RegExp(
        // Do not allow preceding '.', but do allow preceding '...' for spread operations
        // BROWSER VITE patch: no lookbehind for safari support
        '(^|[^\\.]|\\.\\.\\.)\\b(' +
            Object.keys(replacements)
                .map((str) => {
                return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
            })
                .join('|') +
            ')\\b', 'g');
        return [replacements, pattern];
    }
    const defaultPattern = generatePattern(false);
    const ssrPattern = generatePattern(true);
    return {
        name: 'vite:define',
        transform(code, id, options) {
            const ssr = (options === null || options === void 0 ? void 0 : options.ssr) === true;
            if (!ssr && !isBuild) {
                // for dev we inject actual global defines in the vite client to
                // avoid the transform cost.
                return;
            }
            if (
            // exclude css and static assets for performance
            isCSSRequest(id) ||
                config.assetsInclude(id)) {
                return;
            }
            const [replacements, pattern] = ssr ? ssrPattern : defaultPattern;
            if (ssr && !isBuild) {
                // ssr + dev, simple replace
                return code.replace(pattern, (_, prefix, match) => {
                    return prefix + replacements[match];
                });
            }
            const s = new MagicString(code);
            let hasReplaced = false;
            let match;
            while ((match = pattern.exec(code))) {
                hasReplaced = true;
                const start = match.index + match[1].length;
                const end = start + match[2].length;
                const replacement = '' + replacements[match[2]];
                s.overwrite(start, end, replacement);
            }
            if (!hasReplaced) {
                return null;
            }
            const result = { code: s.toString() };
            if (config.build.sourcemap) {
                result.map = s.generateMap({ hires: true });
            }
            return result;
        }
    };
}

/**
 * Resolve base. Note that some users use Vite to build for non-web targets like
 * electron or expects to deploy
 */
function resolveBaseUrl(base = '/', isBuild, logger) {
    // #1669 special treatment for empty for same dir relative base
    if (base === '' || base === './') {
        return isBuild ? base : '/';
    }
    if (base.startsWith('.')) {
        logger.warn(p.yellow.bold(`(!) invalid "base" option: ${base}. The value can only be an absolute ` +
            `URL, ./, or an empty string.`));
        base = '/';
    }
    // external URL
    if (isExternalUrl(base)) {
        if (!isBuild) {
            // get base from full url during dev
            const parsed = parse(base);
            base = parsed.pathname || '/';
        }
    }
    else {
        // ensure leading slash
        if (!base.startsWith('/')) {
            logger.warn(p.yellow.bold(`(!) "base" option should start with a slash.`));
            base = '/' + base;
        }
    }
    // ensure ending slash
    if (!base.endsWith('/')) {
        logger.warn(p.yellow.bold(`(!) "base" option should end with a slash.`));
        base += '/';
    }
    return base;
}
function mergeConfigRecursively(a, b, rootPath) {
    const merged = { ...a };
    for (const key in b) {
        const value = b[key];
        if (value == null) {
            continue;
        }
        const existing = merged[key];
        if (Array.isArray(existing) && Array.isArray(value)) {
            merged[key] = [...existing, ...value];
            continue;
        }
        if (isObject(existing) && isObject(value)) {
            merged[key] = mergeConfigRecursively(existing, value, rootPath ? `${rootPath}.${key}` : key);
            continue;
        }
        // fields that require special handling
        if (existing != null) {
            if (key === 'alias' && (rootPath === 'resolve' || rootPath === '')) {
                merged[key] = mergeAlias(existing, value);
                continue;
            }
            else if (key === 'assetsInclude' && rootPath === '') {
                merged[key] = [].concat(existing, value);
                continue;
            }
            else if (key === 'noExternal' && existing === true) {
                continue;
            }
        }
        merged[key] = value;
    }
    return merged;
}
function mergeConfig(a, b, isRoot = true) {
    return mergeConfigRecursively(a, b, isRoot ? '' : '.');
}
function mergeAlias(a = [], b = []) {
    return [...normalizeAlias(a), ...normalizeAlias(b)];
}
function normalizeAlias(o) {
    return Array.isArray(o)
        ? o.map(normalizeSingleAlias)
        : Object.keys(o).map((find) => normalizeSingleAlias({
            find,
            replacement: o[find]
        }));
}
// https://github.com/vitejs/vite/issues/1363
// work around https://github.com/rollup/plugins/issues/759
function normalizeSingleAlias({ find, replacement }) {
    if (typeof find === 'string' &&
        find.endsWith('/') &&
        replacement.endsWith('/')) {
        find = find.slice(0, find.length - 1);
        replacement = replacement.slice(0, replacement.length - 1);
    }
    return { find, replacement };
}
function sortUserPlugins(plugins) {
    const prePlugins = [];
    const postPlugins = [];
    const normalPlugins = [];
    if (plugins) {
        plugins.flat().forEach((p) => {
            if (p.enforce === 'pre')
                prePlugins.push(p);
            else if (p.enforce === 'post')
                postPlugins.push(p);
            else
                normalPlugins.push(p);
        });
    }
    return [prePlugins, normalPlugins, postPlugins];
}

function resolvePlugin(baseOptions) {
    const { root, 
    // isProduction,
    asSrc, 
    // ssrConfig,
    preferRelative = false } = baseOptions;
    let server;
    return {
        name: 'vite:browser:resolve',
        configureServer(_server) {
            server = _server;
        },
        resolveId(id, importer, resolveOpts) {
            var _a, _b, _c;
            // this is passed by @rollup/plugin-commonjs
            const isRequire = (_c = (_b = (_a = resolveOpts === null || resolveOpts === void 0 ? void 0 : resolveOpts.custom) === null || _a === void 0 ? void 0 : _a['node-resolve']) === null || _b === void 0 ? void 0 : _b.isRequire) !== null && _c !== void 0 ? _c : false;
            const options = {
                isRequire,
                ...baseOptions,
                isFromTsImporter: isTsRequest(importer !== null && importer !== void 0 ? importer : '')
            };
            let res;
            // explicit fs paths that starts with /@fs/*
            if (asSrc && id.startsWith(FS_PREFIX)) {
                const fsPath = fsPathFromId(id);
                res = tryFsResolve(fsPath, options);
                // always return here even if res doesn't exist since /@fs/ is explicit
                // if the file doesn't exist it should be a 404
                return res || fsPath;
            }
            // URL
            // /foo -> /fs-root/foo
            if (asSrc && id.startsWith('/')) {
                const fsPath = path.resolve(root, id.slice(1));
                if ((res = tryFsResolve(fsPath, options))) {
                    return res;
                }
            }
            // relative
            if (id.startsWith('.') || (preferRelative && /^\w/.test(id))) {
                const basedir = importer ? path.dirname(importer) : process.cwd();
                const fsPath = path.resolve(basedir, id);
                // handle browser field mapping for relative imports
                if ((res = tryFsResolve(fsPath, options))) {
                    return res;
                }
            }
            // absolute fs paths
            if (path.isAbsolute(id) && (res = tryFsResolve(id, options))) {
                return res;
            }
            // external
            if (isExternalUrl(id)) {
                return {
                    id,
                    external: true
                };
            }
            // data uri: pass through (this only happens during build and will be
            // handled by dedicated plugin)
            if (isDataUrl(id)) {
                return null;
            }
        }
    };
}
function tryFsResolve(fsPath, options, tryIndex = true, targetWeb = true) {
    let file = fsPath;
    let postfix = '';
    let postfixIndex = fsPath.indexOf('?');
    if (postfixIndex < 0) {
        postfixIndex = fsPath.indexOf('#');
    }
    if (postfixIndex > 0) {
        file = fsPath.slice(0, postfixIndex);
        postfix = fsPath.slice(postfixIndex);
    }
    let res;
    // if we fould postfix exist, we should first try resolving file with postfix. details see #4703.
    if (postfix &&
        (res = tryResolveFile(fsPath, '', options, false, targetWeb, options.tryPrefix))) {
        return res;
    }
    if ((res = tryResolveFile(file, postfix, options, false, targetWeb, options.tryPrefix))) {
        return res;
    }
    for (const ext of options.extensions || DEFAULT_EXTENSIONS) {
        if (postfix &&
            (res = tryResolveFile(fsPath + ext, '', options, false, targetWeb, options.tryPrefix))) {
            return res;
        }
        if ((res = tryResolveFile(file + ext, postfix, options, false, targetWeb, options.tryPrefix))) {
            return res;
        }
    }
    if (postfix &&
        (res = tryResolveFile(fsPath, '', options, tryIndex, targetWeb, options.tryPrefix))) {
        return res;
    }
    if ((res = tryResolveFile(file, postfix, options, tryIndex, targetWeb, options.tryPrefix))) {
        return res;
    }
}
function tryResolveFile(file, postfix, options, tryIndex, targetWeb, tryPrefix, skipPackageJson) {
    if (!file.startsWith(options.root))
        return undefined;
    if (fs.existsSync(file)) {
        return file + postfix;
    }
    else if (tryIndex) {
        const index = tryFsResolve(file + '/index', options, false);
        if (index)
            return index + postfix;
    }
    const tryTsExtension = options.isFromTsImporter && isPossibleTsOutput(file);
    if (tryTsExtension) {
        const tsSrcPath = getTsSrcPath(file);
        return tryResolveFile(tsSrcPath, postfix, options, tryIndex, targetWeb, tryPrefix);
    }
    if (tryPrefix) {
        const prefixed = `${path.dirname(file)}/${tryPrefix}${path.basename(file)}`;
        return tryResolveFile(prefixed, postfix, options, tryIndex, targetWeb);
    }
}
function tryOptimizedResolve(id, server, importer) {
    const cacheDir = server.config.cacheDir;
    const depData = server._optimizeDepsMetadata;
    if (!cacheDir || !depData)
        return;
    const getOptimizedUrl = (optimizedData) => {
        return optimizedData.file; //+
        // `?v=${depData.browserHash}${
        //   optimizedData.needsInterop ? `&es-interop` : ``
        // }`
    };
    // check if id has been optimized
    const isOptimized = depData.optimized[id];
    if (isOptimized) {
        return getOptimizedUrl(isOptimized);
    }
    if (!importer)
        return;
}

/**
 * A plugin to avoid an aliased AND optimized dep from being aliased in src
 */
function preAliasPlugin() {
    let server;
    return {
        name: 'vite:browser:pre-alias',
        configureServer(_server) {
            server = _server;
        },
        resolveId(id, importer, options) {
            if (!(options === null || options === void 0 ? void 0 : options.ssr) && bareImportRE.test(id)) {
                return tryOptimizedResolve(id, server, importer);
            }
        }
    };
}

async function resolvePlugins(config, prePlugins, normalPlugins, postPlugins) {
    const isBuild = config.command === 'build';
    const buildPlugins = { pre: [], post: [] };
    return [
        isBuild ? null : preAliasPlugin(),
        aliasPlugin({
            entries: config.resolve.alias,
            customResolver: function (updatedId, importer) {
                return this.resolve(updatedId, importer, { skipSelf: true });
            }
        }),
        ...prePlugins,
        // config.build.polyfillModulePreload
        //   ? modulePreloadPolyfillPlugin(config)
        //   : null,
        resolvePlugin({
            ...config.resolve,
            root: config.root,
            isProduction: config.isProduction,
            isBuild,
            packageCache: config.packageCache,
            ssrConfig: config.ssr,
            asSrc: true
        }),
        // config.build.ssr ? ssrRequireHookPlugin(config) : null,
        htmlInlineScriptProxyPlugin(config),
        cssPlugin(config),
        config.esbuild !== false ? esbuildPlugin(config.esbuild) : null,
        jsonPlugin({
            namedExports: true,
            ...config.json
        }, isBuild),
        // wasmPlugin(config),
        // webWorkerPlugin(config),
        assetPlugin(config),
        ...normalPlugins,
        definePlugin(config),
        cssPostPlugin(config),
        ...buildPlugins.pre,
        ...postPlugins,
        ...buildPlugins.post,
        // internal server-only plugins are always applied after everything else
        ...(isBuild
            ? []
            : [clientInjectionsPlugin(config), importAnalysisPlugin(config)])
    ].filter(Boolean);
}

function resolveServerOptions(root, raw) {
    var _a, _b, _c, _d;
    const server = raw || {};
    let allowDirs = (_a = server.fs) === null || _a === void 0 ? void 0 : _a.allow;
    const deny = ((_b = server.fs) === null || _b === void 0 ? void 0 : _b.deny) || ['.env', '.env.*', '*.{crt,pem}'];
    if (!allowDirs) {
        allowDirs = [root];
    }
    server.fs = {
        strict: (_d = (_c = server.fs) === null || _c === void 0 ? void 0 : _c.strict) !== null && _d !== void 0 ? _d : true,
        allow: allowDirs,
        deny
    };
    return server;
}

async function resolveConfig(inlineConfig, command, defaultMode = 'development') {
    var _a, _b, _c, _d;
    let config = inlineConfig;
    const mode = defaultMode;
    const isProduction = false;
    const configEnv = {
        mode,
        command
    };
    // Define logger
    const logger = {
        info: (s) => console.log(s),
        warn: (s) => console.log(s),
        error: (s) => console.log(s),
        clearScreen: () => {
            /* empty */
        },
        hasErrorLogged: () => false,
        hasWarned: false,
        warnOnce: (s) => console.warn(s)
    };
    // resolve plugins
    const rawUserPlugins = (config.plugins || []).flat().filter((p) => {
        if (!p) {
            return false;
        }
        else if (!p.apply) {
            return true;
        }
        else if (typeof p.apply === 'function') {
            return p.apply({ ...config, mode }, configEnv);
        }
        else {
            return p.apply === command;
        }
    });
    const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins(rawUserPlugins);
    // run config hooks
    const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins];
    for (const p of userPlugins) {
        if (p.config) {
            const res = await p.config(config, configEnv);
            if (res) {
                config = mergeConfig(config, res);
            }
        }
    }
    // resolve root
    const resolvedRoot = normalizePath(config.root ? path.resolve(config.root) : process.cwd());
    const clientAlias = [
        { find: /^[\/]?@vite\/env/, replacement: () => ENV_ENTRY },
        { find: /^[\/]?@vite\/client/, replacement: () => CLIENT_ENTRY }
    ];
    // resolve alias with internal client alias
    const resolvedAlias = mergeAlias(
    // @ts-ignore because @rollup/plugin-alias' type doesn't allow function
    // replacement, but its implementation does work with function values.
    clientAlias, ((_a = config.resolve) === null || _a === void 0 ? void 0 : _a.alias) || config.alias || []);
    const resolveOptions = {
        dedupe: config.dedupe,
        ...config.resolve,
        alias: resolvedAlias
    };
    // resolve public base url
    const BASE_URL = resolveBaseUrl(config.base, command === 'build', logger);
    const resolvedBuildOptions = resolveBuildOptions(resolvedRoot, config.build);
    const cacheDir = config.cacheDir;
    // create an internal resolver to be used in special scenarios, e.g.
    // optimizer & handling css @imports
    const createResolver = (options) => {
        let aliasContainer;
        let resolverContainer;
        const createAliasPlugin = () => aliasPlugin({
            entries: resolved.resolve.alias,
            customResolver: function (updatedId, importer) {
                return this.resolve(updatedId, importer, { skipSelf: true });
            }
        });
        return async (id, importer, aliasOnly, ssr) => {
            var _a;
            let container;
            if (aliasOnly) {
                container =
                    aliasContainer ||
                        (aliasContainer = await createPluginContainer({
                            ...resolved,
                            plugins: [createAliasPlugin()]
                        }));
            }
            else {
                container =
                    resolverContainer ||
                        (resolverContainer = await createPluginContainer({
                            ...resolved,
                            plugins: [
                                createAliasPlugin(),
                                resolvePlugin({
                                    ...resolved.resolve,
                                    root: resolvedRoot,
                                    isProduction,
                                    isBuild: command === 'build',
                                    ssrConfig: resolved.ssr,
                                    asSrc: true,
                                    preferRelative: false,
                                    tryIndex: true,
                                    ...options
                                })
                            ]
                        }));
            }
            return (_a = (await container.resolveId(id, importer, { ssr }))) === null || _a === void 0 ? void 0 : _a.id;
        };
    };
    const { publicDir } = config;
    const resolvedPublicDir = publicDir !== false && publicDir !== ''
        ? path.resolve(resolvedRoot, typeof publicDir === 'string' ? publicDir : 'public')
        : '';
    const server = resolveServerOptions(resolvedRoot, config.server);
    const resolved = {
        ...config,
        configFile: undefined,
        configFileDependencies: [],
        inlineConfig,
        root: resolvedRoot,
        base: BASE_URL,
        resolve: resolveOptions,
        publicDir: resolvedPublicDir,
        cacheDir,
        command,
        mode,
        isProduction,
        plugins: userPlugins,
        server,
        build: resolvedBuildOptions,
        preview: undefined,
        env: {
            BASE_URL,
            MODE: mode,
            DEV: !isProduction,
            PROD: isProduction
        },
        assetsInclude(file) {
            return DEFAULT_ASSETS_RE.test(file);
        },
        logger,
        packageCache: new Map(),
        createResolver,
        optimizeDeps: {
            ...config.optimizeDeps,
            esbuildOptions: {
                keepNames: (_b = config.optimizeDeps) === null || _b === void 0 ? void 0 : _b.keepNames,
                preserveSymlinks: (_c = config.resolve) === null || _c === void 0 ? void 0 : _c.preserveSymlinks,
                ...(_d = config.optimizeDeps) === null || _d === void 0 ? void 0 : _d.esbuildOptions
            }
        }
    };
    resolved.plugins = await resolvePlugins(resolved, prePlugins, normalPlugins, postPlugins);
    // call configResolved hooks
    await Promise.all(userPlugins.map((p) => { var _a; return (_a = p.configResolved) === null || _a === void 0 ? void 0 : _a.call(p, resolved); }));
    return resolved;
}

const debugHmr = createDebugger('vite:hmr');
const normalizedClientDir = normalizePath(CLIENT_DIR);
function getShortName(file, root) {
    return file.startsWith(root + '/') ? path.posix.relative(root, file) : file;
}
async function handleHMRUpdate(file, content, server) {
    const { ws, config, moduleGraph } = server;
    const shortFile = getShortName(file, config.root);
    const isConfig = file === config.configFile;
    const isConfigDependency = config.configFileDependencies.some((name) => file === path.resolve(name));
    const isEnv = config.inlineConfig.envFile !== false &&
        (file === '.env' || file.startsWith('.env.'));
    if (isConfig || isConfigDependency || isEnv) {
        // auto restart server
        debugHmr(`[config change] ${p.dim(shortFile)}`);
        config.logger.info(p.green(`${path.relative(process.cwd(), file)} changed, restarting server...`), { clear: true, timestamp: true });
        await server.restart();
        return;
    }
    debugHmr(`[file change] ${p.dim(shortFile)}`);
    // (dev only) the client itself cannot be hot updated.
    if (file.startsWith(normalizedClientDir)) {
        ws.send({
            type: 'full-reload',
            path: '*'
        });
        return;
    }
    const mods = moduleGraph.getModulesByFile(file);
    // check if any plugin wants to perform custom HMR handling
    const timestamp = Date.now();
    const hmrContext = {
        file,
        timestamp,
        modules: mods ? [...mods] : [],
        read: () => content,
        server
    };
    for (const plugin of config.plugins) {
        if (plugin.handleHotUpdate) {
            const filteredModules = await plugin.handleHotUpdate(hmrContext);
            if (filteredModules) {
                hmrContext.modules = filteredModules;
            }
        }
    }
    if (!hmrContext.modules.length) {
        // html file cannot be hot updated
        if (file.endsWith('.html')) {
            config.logger.info(p.green(`page reload `) + p.dim(shortFile), {
                clear: true,
                timestamp: true
            });
            ws.send({
                type: 'full-reload',
                path: config.server.middlewareMode
                    ? '*'
                    : '/' + normalizePath(path.relative(config.root, file))
            });
        }
        else {
            // loaded but not in the module graph, probably not js
            debugHmr(`[no modules matched] ${p.dim(shortFile)}`);
        }
        return;
    }
    updateModules(shortFile, hmrContext.modules, timestamp, server);
}
function updateModules(file, modules, timestamp, { config, ws }) {
    const updates = [];
    const invalidatedModules = new Set();
    let needFullReload = false;
    for (const mod of modules) {
        invalidate(mod, timestamp, invalidatedModules);
        if (needFullReload) {
            continue;
        }
        const boundaries = new Set();
        const hasDeadEnd = propagateUpdate(mod, boundaries);
        if (hasDeadEnd) {
            needFullReload = true;
            continue;
        }
        updates.push(...[...boundaries].map(({ boundary, acceptedVia }) => ({
            type: `${boundary.type}-update`,
            timestamp,
            path: boundary.url,
            acceptedPath: acceptedVia.url
        })));
    }
    if (needFullReload) {
        config.logger.info(p.green(`page reload `) + p.dim(file), {
            clear: true,
            timestamp: true
        });
        ws.send({
            type: 'full-reload'
        });
    }
    else {
        config.logger.info(updates
            .map(({ path }) => p.green(`hmr update `) + p.dim(path))
            .join('\n'), { clear: true, timestamp: true });
        ws.send({
            type: 'update',
            updates
        });
    }
}
async function handleFileAddUnlink(file, server, isUnlink = false) {
    var _a;
    const modules = [...((_a = server.moduleGraph.getModulesByFile(file)) !== null && _a !== void 0 ? _a : [])];
    if (isUnlink && file in server._globImporters) {
        delete server._globImporters[file];
    }
    if (modules.length > 0) {
        updateModules(getShortName(file, server.config.root), modules, Date.now(), server);
    }
}
function propagateUpdate(node, boundaries, currentChain = [node]) {
    if (node.isSelfAccepting) {
        boundaries.add({
            boundary: node,
            acceptedVia: node
        });
        // additionally check for CSS importers, since a PostCSS plugin like
        // Tailwind JIT may register any file as a dependency to a CSS file.
        for (const importer of node.importers) {
            if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
                propagateUpdate(importer, boundaries, currentChain.concat(importer));
            }
        }
        return false;
    }
    if (!node.importers.size) {
        return true;
    }
    // #3716, #3913
    // For a non-CSS file, if all of its importers are CSS files (registered via
    // PostCSS plugins) it should be considered a dead end and force full reload.
    if (!isCSSRequest(node.url) &&
        [...node.importers].every((i) => isCSSRequest(i.url))) {
        return true;
    }
    for (const importer of node.importers) {
        const subChain = currentChain.concat(importer);
        if (importer.acceptedHmrDeps.has(node)) {
            boundaries.add({
                boundary: importer,
                acceptedVia: node
            });
            continue;
        }
        if (currentChain.includes(importer)) {
            // circular deps is considered dead end
            return true;
        }
        if (propagateUpdate(importer, boundaries, subChain)) {
            return true;
        }
    }
    return false;
}
function invalidate(mod, timestamp, seen) {
    if (seen.has(mod)) {
        return;
    }
    seen.add(mod);
    mod.lastHMRTimestamp = timestamp;
    mod.transformResult = null;
    mod.ssrModule = null;
    mod.ssrTransformResult = null;
    mod.importers.forEach((importer) => {
        if (!importer.acceptedHmrDeps.has(mod)) {
            invalidate(importer, timestamp, seen);
        }
    });
}

const pendingModules = new Map();
const pendingImports = new Map();
async function ssrLoadModule(url, server, nodeImport, context = { global }, urlStack = []) {
    url = unwrapId(url);
    // when we instantiate multiple dependency modules in parallel, they may
    // point to shared modules. We need to avoid duplicate instantiation attempts
    // by register every module as pending synchronously so that all subsequent
    // request to that module are simply waiting on the same promise.
    const pending = pendingModules.get(url);
    if (pending) {
        return pending;
    }
    const modulePromise = instantiateModule(url, server, nodeImport, context, urlStack);
    pendingModules.set(url, modulePromise);
    modulePromise
        .catch(() => {
        pendingImports.delete(url);
    })
        .finally(() => {
        pendingModules.delete(url);
    });
    return modulePromise;
}
async function instantiateModule(url, server, nodeImport, context = { global }, urlStack = []) {
    const { moduleGraph } = server;
    const mod = await moduleGraph.ensureEntryFromUrl(url, true);
    if (mod.ssrModule) {
        return mod.ssrModule;
    }
    const result = mod.ssrTransformResult ||
        (await transformRequest(url, server, { ssr: true }));
    if (!result) {
        // TODO more info? is this even necessary?
        throw new Error(`failed to load module for ssr: ${url}`);
    }
    const ssrModule = {
        [Symbol.toStringTag]: 'Module'
    };
    Object.defineProperty(ssrModule, '__esModule', { value: true });
    // Tolerate circular imports by ensuring the module can be
    // referenced before it's been instantiated.
    mod.ssrModule = ssrModule;
    const ssrImportMeta = {
        // The filesystem URL, matching native Node.js modules
        url: pathToFileURL(mod.file).toString()
    };
    urlStack = urlStack.concat(url);
    const isCircular = (url) => urlStack.includes(url);
    // Since dynamic imports can happen in parallel, we need to
    // account for multiple pending deps and duplicate imports.
    const pendingDeps = [];
    const ssrImport = async (dep) => {
        var _a, _b;
        dep = unwrapId(dep);
        if (dep[0] !== '.' && dep[0] !== '/') {
            return proxyESM(await nodeImport(dep));
        }
        if (!isCircular(dep) && !((_a = pendingImports.get(dep)) === null || _a === void 0 ? void 0 : _a.some(isCircular))) {
            pendingDeps.push(dep);
            if (pendingDeps.length === 1) {
                pendingImports.set(url, pendingDeps);
            }
            const mod = await ssrLoadModule(dep, server, nodeImport, context, urlStack);
            if (pendingDeps.length === 1) {
                pendingImports.delete(url);
            }
            else {
                pendingDeps.splice(pendingDeps.indexOf(dep), 1);
            }
            // return local module to avoid race condition #5470
            return mod;
        }
        return (_b = moduleGraph.urlToModuleMap.get(dep)) === null || _b === void 0 ? void 0 : _b.ssrModule;
    };
    const ssrDynamicImport = (dep) => {
        // #3087 dynamic import vars is ignored at rewrite import path,
        // so here need process relative path
        if (dep[0] === '.') {
            dep = path.posix.resolve(path.dirname(url), dep);
        }
        return ssrImport(dep);
    };
    function ssrExportAll(sourceModule) {
        for (const key in sourceModule) {
            if (key !== 'default') {
                Object.defineProperty(ssrModule, key, {
                    enumerable: true,
                    configurable: true,
                    get() {
                        return sourceModule[key];
                    }
                });
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    const AsyncFunction = async function () { }.constructor;
    const initModule = new AsyncFunction(`global`, ssrModuleExportsKey, ssrImportMetaKey, ssrImportKey, ssrDynamicImportKey, ssrExportAllKey, result.code + `\n//# sourceURL=${mod.url}`);
    await initModule(context.global, ssrModule, ssrImportMeta, ssrImport, ssrDynamicImport, ssrExportAll);
    return Object.freeze(ssrModule);
}
// rollup-style default import interop for cjs
function proxyESM(mod) {
    // This is the only sensible option when the exports object is a primitve
    if (isPrimitive(mod))
        return { default: mod };
    let defaultExport = 'default' in mod ? mod.default : mod;
    if (!isPrimitive(defaultExport) && '__esModule' in defaultExport) {
        mod = defaultExport;
        if ('default' in defaultExport) {
            defaultExport = defaultExport.default;
        }
    }
    return new Proxy(mod, {
        get(mod, prop) {
            var _a;
            if (prop === 'default')
                return defaultExport;
            return (_a = mod[prop]) !== null && _a !== void 0 ? _a : defaultExport === null || defaultExport === void 0 ? void 0 : defaultExport[prop];
        }
    });
}
function isPrimitive(value) {
    return !value || (typeof value !== 'object' && typeof value !== 'function');
}

export { CLIENT_DIR, CLIENT_ENTRY, ENV_ENTRY, ModuleGraph, createDevHtmlTransformFn, createMissingImporterRegisterFn, createPluginContainer, flattenId, generateCodeFrame, handleFileAddUnlink, handleHMRUpdate, injectQuery, isCSSRequest, isDirectCSSRequest, normalizePath, posToNumber, removeImportQuery, resolveConfig, scanImports, ssrLoadModule, ssrTransform, transformRequest, transformWithEsbuild, unwrapId };
//# sourceMappingURL=index.js.map
